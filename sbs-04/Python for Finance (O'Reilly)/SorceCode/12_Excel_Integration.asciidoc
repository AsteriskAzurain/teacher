[[excel_integration]]


== Excel Integration

[quote, Kirat Singh]
____
[role="align_me_right"]
Microsoft Excel is probably the most successful data analytics platform of all times.
____


((("Microsoft Excel", see="Excel")))(((Excel, benefits of)))It is fair to say that Microsoft ++Excel++—as part of Microsoft's ++Office++ suite of productivity tools--is one of the most widely used tools and applications in the finance industry and the finance functions of corporate and other institutions. What started out as a computerized version of paper spreadsheets has become a multipurpose tool for financial analysis and financial application building (in addition to the many use cases in other fields and industries).

(((Excel, features of)))Spreadsheet applications, like Microsoft +Excel+ and LibreOffice +Calc+, are characterized by a few main features:

Organization:: 
    A _workbook_ is a spreadsheet application file that is organized in 
    single _sheets_ that in turn are organized in _cells_.
Data:: 
    Data is generally stored in tabular form in single cells; the cells 
    contain the data itself (e.g., a floating-point number or a text 
    string), formatting information for display purposes (e.g., font type,     
    color), and maybe some computer code (if, for example, the data in 
    the cell is the result of a numerical operation).
Functionality:: 
    Given the data stored in single cells, you can do computational and     
    other operations with that data, like adding or multiplying integers.
Visualization:: 
    Data can be easily visualized, for example, as a pie chart.
Programmability:: 
    Modern spreadsheet applications allow highly flexible programmability, 
    e.g., via ++Visual Basic for Applications++ (+VBA+) within an +Excel+ 
    spreadsheet.
References:: 
    The major tool for implementing functionality or writing, e.g., ++VBA++ 
    code is the _cell reference_; every cell has unique coordinates 
    (workbook, sheet name, column, and row) identifying the cell.

This brief characterization might explain the popularity: all technical elements needed to implement financial analyses or applications are found in a single place. Thinking of +Python+ and the previous chapters, you need a couple of libraries and tools (+Python+, +NumPy+, +matplotlib+, +PyTables+, etc.) combined to have available all of the features just listed.

(((Excel, drawbacks of)))((("graphical user interfaces (GUIs)", "Microsoft Excel as")))Such convenience and one-size-fits-all approaches generally come at a cost, though. To pick just one area, spreadsheets are _not_ suited to storing large amounts of data or data with complex relationships. This is the reason why Microsoft +Excel+ in the finance industry has developed more as a _general graphical user interface_ (GUI) "only." In many cases, it is mainly used to display and visualize data and aggregate information and to implement ad hoc analyses. For example, there are interfaces available to get data from leading data service providers, like Bloomberg and Thomson Reuters, into +Excel+ (and maybe the other way around).

(((Excel, integration with Python)))This chapter works on the assumption that Microsoft +Excel+ is available on almost every desktop or notebook computer and that it is used as a general GUI. In this sense, +Python+ can play the following roles:

Manipulation tool:: 
    Using +Python+, you can interact with and manipulate +Excel+ 
    spreadsheets.
Data processor:: 
    +Python+ can provide data to a spreadsheet and read data from a 
    spreadsheet.
Analytics engine:: 
    +Python+ can provide its whole analytics capabilities to spreadsheets,     
    becoming a full-fledged substitute for ++VBA++ programming.


=== Basic Spreadsheet Interaction

((("Excel", "basic spreadsheet interaction", id="ix_Espread", range="startofrange")))(((spreadsheets, Python libraries for)))(((xlrd library)))(((xlwt library)))(((xlsxwriter library)))Fundamental +Python+ libraries to work with +Excel+ spreadsheet files are +xlrd+ and +xlwt+ (cf. http://www.python-excel.org[]). Although quite popular, a major drawback of +xlwt+ is that it can only write spreadsheet files compatible with Microsoft +Excel+ ++97++/++2000++/++XP++/++2003++, OpenOffice.org +Calc+, and ++Gnumeric++—i.e., those with the suffix +.xls+. Therefore, we also use the libraries http://xlsxwriter.readthedocs.org[+xlsxwriter+] and http://openpyxl.readthedocs.org[+OpenPyxl+], which generate spreadsheet files in the current +.xslx+ format. We'll begin, then, with a few imports.

// code cell start uuid: afcf7ac4-6e55-4f16-af31-89bcb2975356
[source, python]
----
In [1]: import numpy as np
        import pandas as pd
        import xlrd, xlwt
        import xlsxwriter
        path = 'data/'
----

// code cell end


==== Generating Workbooks (.xls)

(((spreadsheets, generating xls workbooks)))(((workbooks, generating xls workbooks)))((("comma-separated value (CSV) files", "generating Excel spreadsheets with")))We start by generating a workbook with two sheets.footnote:[Note that a simple mechanism to generate +Excel+ spreadsheets from +Python+ is to export data in the form of a comma-separated value (++CSV++) file and to import this with +Excel+. This might sometimes be more efficient than the ways presented in the following discussion.] First, the +Workbook+ object +wb+. Note that this is an _in-memory_ version of the workbook only (so far):

// code cell start uuid: 78a2d1aa-68bb-4efc-bb07-33940d780bb4
[source, python]
----
In [2]: wb = xlwt.Workbook()
----

// code cell end

// code cell start uuid: 4733e4f7-22bc-4830-b70d-75210b9f5099
[source, python]
----
In [3]: wb
----

----
Out[3]: <xlwt.Workbook.Workbook at 0x7f7dcc49df10>
----

// code cell end

The second step is to add one or multiple sheets to the +Workbook+ object:

// code cell start uuid: 3642dc8c-25eb-4182-9cdf-00929f361a18
[source, python]
----
In [4]: wb.add_sheet('first_sheet', cell_overwrite_ok=True)
----

----
Out[4]: <xlwt.Worksheet.Worksheet at 0x7f7dac9dde90>
----

// code cell end

We now have one +Worksheet+ object, which has index number 0:

// code cell start uuid: 7c3e80b7-763b-40bf-95ef-baeb82bed88d
[source, python]
----
In [5]: wb.get_active_sheet()
----

----
Out[5]: 0
----

// code cell end

To further work with the sheet, define an alias for it:

// code cell start uuid: eaeb018a-c028-4ae6-812b-0a792491926a
[source, python]
----
In [6]: ws_1 = wb.get_sheet(0)
        ws_1
----

----
Out[6]: <xlwt.Worksheet.Worksheet at 0x7f7dac9dde90>
----

// code cell end

Of course, these two steps--instantiation and alias definition--can be combined into a single step:

// code cell start uuid: fec1d55e-4ca6-4391-9547-74469632e499
[source, python]
----
In [7]: ws_2 = wb.add_sheet('second_sheet')
----

// code cell end

Both +Worksheet+ objects are still empty. Therefore, let us generate a +NumPy+ +ndarray+ object containing some numbers:

// code cell start uuid: 3f082bb9-5871-4e45-92eb-917421a5607d
[source, python]
----
In [8]: data = np.arange(1, 65).reshape((8, 8))
----

// code cell end

// code cell start uuid: 586d40cb-a458-4df0-b6e3-35035df08f05
[source, python]
----
In [9]: data
----

----
Out[9]: array([[ 1,  2,  3,  4,  5,  6,  7,  8],
               [ 9, 10, 11, 12, 13, 14, 15, 16],
               [17, 18, 19, 20, 21, 22, 23, 24],
               [25, 26, 27, 28, 29, 30, 31, 32],
               [33, 34, 35, 36, 37, 38, 39, 40],
               [41, 42, 43, 44, 45, 46, 47, 48],
               [49, 50, 51, 52, 53, 54, 55, 56],
               [57, 58, 59, 60, 61, 62, 63, 64]])
----

// code cell end

Using the +write+ method and providing row and column information (with zero-based indexing), data is easily written to a certain cell in a certain worksheet:

// code cell start uuid: bf1c726a-1d15-454e-b9bf-a8b4c0314cec
[source, python]
----
In [10]: ws_1.write(0, 0, 100)
           # write 100 in cell "A1"
----

// code cell end

This way, the sample data can be written "in bulk" to the two +Worksheet+ objects:

// code cell start uuid: f4dbf31c-45b6-4fa9-b350-d3e3570b1ae9
[source, python]
----
In [11]: for c in range(data.shape[0]):
             for r in range(data.shape[1]):
                 ws_1.write(r, c, data[c, r])
                 ws_2.write(r, c, data[r, c])
----

// code cell end

The +save+ method of the +Workbook+ class allows us to save the whole +Workbook+ object pass:[<phrase role="keep-together">to disk</phrase>]:

// code cell start uuid: ca250260-27d4-4d60-b82c-8b14ec1def9d
[source, python]
----
In [12]: wb.save(path + 'workbook.xls')
----

// code cell end

On +Windows+ systems, the path might look like +r"C:\path\data\workbook.xls"+.


==== Generating Workbooks (.xslx)

(((spreadsheets, generating xlsx workbooks)))(((workbooks, generating xlsx workbooks)))(The creation of spreadsheet files in the new format works essentially the same way. First, we create a +Workbook+ object:

// code cell start uuid: 2e82cdbd-68be-4769-936a-7c4598da7b75
[source, python]
----
In [13]: wb = xlsxwriter.Workbook(path + 'workbook.xlsx')
----

// code cell end

Second, the +Worksheet+ objects:

// code cell start uuid: 95bbd41a-158f-4a67-8ff2-d5f7b9ed730d
[source, python]
----
In [14]: ws_1 = wb.add_worksheet('first_sheet')
         ws_2 = wb.add_worksheet('second_sheet')
----

// code cell end

Third, we write data to the +Worksheet+ objects:

// code cell start uuid: 478f1615-5147-4c93-a098-d50a53ac1692
[source, python]
----
In [15]: for c in range(data.shape[0]):
             for r in range(data.shape[1]):
                 ws_1.write(r, c, data[c, r])
                 ws_2.write(r, c, data[r, c])
----

// code cell end

Fourth, we close the +Workbook+ file object:

// code cell start uuid: b45daff9-9ea0-46a4-b8ac-c32dcf1accf2
[source, python]
----
In [16]: wb.close()
----

// code cell end

// code cell start uuid: 9dddedc0-c294-4910-aee5-dfd0316ce270
[source, python]
----
In [17]: ll $path*
----

----
Out[17]: -rw------- 1 yhilpisch 7375 Sep 28 18:18 data/chart.xlsx
         -rw------- 1 yhilpisch 5632 Sep 28 18:18 data/workbook.xls
         -rw------- 1 yhilpisch 6049 Sep 28 18:18 data/workbook.xlsx
         
----

// code cell end

If everything went well, the file opened in Microsoft +Excel+ should look like <<excel_1>>.

[[excel_1]]
.Screenshot of workbook in Excel
image::images/pyfi_1201.png[]

+xlsxwriter+ has many more options to generate +Workbook+ objects, for example with charts. Consider the following code (cf. the http://bit.ly/xlsxwriter[++xlsxwriter++ documentation]):

// code cell start uuid: 1de6f4b9-b9ca-46d1-babd-60c02c426871
[source, python]
----
In [18]: wb = xlsxwriter.Workbook(path + 'chart.xlsx')
         ws = wb.add_worksheet()
         
         # write cumsum of random values in first column
         values = np.random.standard_normal(15).cumsum()
         ws.write_column('A1', values)
         
         # create a new chart object
         chart = wb.add_chart({'type': 'line'})
         
         # add a series to the chart
         chart.add_series({'values': '=Sheet1!$A$1:$A$15',
                           'marker': {'type': 'diamond'},})
           # series with markers (here: diamond)
         
         # insert the chart
         ws.insert_chart('C1', chart)
         
         wb.close()
----

// code cell end

The resulting spreadsheet file is shown as a screenshot in <<excel_2>>.

[[excel_2]]
.Screenshot of workbook in Excel with a chart
image::images/pyfi_1202.png[]


==== Reading from Workbooks

(((workbooks, reading from)))(((spreadsheets, reading from workbooks)))The sister library +xlrd+ is responsible for reading data from spreadsheet files (i.e., pass:[<phrase role="keep-together">workbooks</phrase>]):

// code cell start uuid: 0b447795-de63-4893-a587-17757de0ed43
[source, python]
----
In [19]: book = xlrd.open_workbook(path + 'workbook.xlsx')
----

// code cell end

// code cell start uuid: 2f8e1a77-f30e-48b6-877f-5c022726ef6a
[source, python]
----
In [20]: book
----

----
Out[20]: <xlrd.book.Book at 0x7f7dabec4890>
----

// code cell end

Once a workbook is opened, the +sheet_names+ method provides the names of all +Worksheet+ objects in this particular +Workbook+ object:

// code cell start uuid: 14534892-0353-4e8c-b55e-1d052623381f
[source, python]
----
In [21]: book.sheet_names()
----

----
Out[21]: [u'first_sheet', u'second_sheet']
----

// code cell end

++Worksheet++s can be accessed via their names or index values:

// code cell start uuid: 92920fc9-6b93-4410-beb1-e556cd9b2b46
[source, python]
----
In [22]: sheet_1 = book.sheet_by_name('first_sheet')
         sheet_2 = book.sheet_by_index(1)
         sheet_1
----

----
Out[22]: <xlrd.sheet.Sheet at 0x7f7dabec4a10>
----

// code cell end

// code cell start uuid: 9d1e412e-b41a-4583-bab1-bf028eb95bcf
[source, python]
----
In [23]: sheet_2.name
----

----
Out[23]: u'second_sheet'
----

// code cell end

Important attributes of a +Worksheet+ object are +ncols+ and +nrows+, indicating the number of columns and rows, respectively, that contain data:

// code cell start uuid: 38004e12-ab84-4e9f-8665-9bf41ad38628
[source, python]
----
In [24]: sheet_1.ncols, sheet_1.nrows
----

----
Out[24]: (8, 8)
----

// code cell end

Single cells—i.e. +Cell+ objects—are accessed via the +cell+ method, providing the numbers for both the row and the column (again, numbering is zero-based). The +value+ attribute then gives the data stored in this particular cell:

// code cell start uuid: 8cc96ed8-787d-438a-b2c8-9de1ce5d3084
[source, python]
----
In [25]: cl = sheet_1.cell(0, 0)
         cl.value
----

----
Out[25]: 1.0
----

// code cell end

The attribute +ctype+ gives the cell type:

// code cell start uuid: 388a04e6-1cdc-4fcb-b65d-9639fe2b3fca
[source, python]
----
In [26]: cl.ctype
----

----
Out[26]: 2
----

// code cell end

(((spreadsheets, Excel cell types)))(((Excel, cell types in)))(((cells, in Excel spreadsheets)))<<excel_cell_types>> lists all +Excel+ cell types.

[[excel_cell_types]]
.Excel cell types
[options="header, unbreakable"]
|=======
|Type 	           | Number |	+Python+ type
|+XL_CELL_EMPTY+   | 0   | Empty +string+
|+XL_CELL_TEXT+    | 1 	| A Unicode +string+
|+XL_CELL_NUMBER+  | 2  | +float+
|+XL_CELL_DATE+    | 3 	| +float+
|+XL_CELL_BOOLEAN+ | 4 	| +int+ (1 = +TRUE+, 0 = +FALSE+)
|+XL_CELL_ERROR+   | 5 	| +int+ representing internal +Excel+ codes
|+XL_CELL_BLANK+   | 6 	| Empty +string+, only when +formatting_info=True+
|=======

Similarly, you can access whole rows by providing the number of the row to the +row+ method:

// code cell start uuid: e13520db-f2dd-4ee7-bf61-22e680e8ab87
[source, python]
----
In [27]: sheet_2.row(3)
----

----
Out[27]: [number:25.0,
          number:26.0,
          number:27.0,
          number:28.0,
          number:29.0,
          number:30.0,
          number:31.0,
          number:32.0]
----

// code cell end

And, analogously, whole columns:

// code cell start uuid: d09bb78b-cf07-486d-a8bd-5c163deff76b
[source, python]
----
In [28]: sheet_2.col(3)
----

----
Out[28]: [number:4.0,
          number:12.0,
          number:20.0,
          number:28.0,
          number:36.0,
          number:44.0,
          number:52.0,
          number:60.0]
----

// code cell end

The methods +row_values+ and +col_values+ only deliver the values contained in the respective row or column:

// code cell start uuid: 689202bf-5d67-407a-942e-c98cd096fdf4
[source, python]
----
In [29]: sheet_1.col_values(3, start_rowx=3, end_rowx=7)
----

----
Out[29]: [28.0, 29.0, 30.0, 31.0]
----

// code cell end

// code cell start uuid: 4efd595d-15ae-406b-8d44-bd5d695cd3db
[source, python]
----
In [30]: sheet_1.row_values(3, start_colx=3, end_colx=7)
----

----
Out[30]: [28.0, 36.0, 44.0, 52.0]
----

// code cell end

To read out all the data in a +Worksheet+ object, just iterate over all columns and rows that contain data:

// code cell start uuid: bc0c08a2-fee0-4ef7-a25b-b46c1d943afc
[source, python]
----
In [31]: for c in range(sheet_1.ncols):
             for r in range(sheet_1.nrows):
                 print '%i' % sheet_1.cell(r, c).value,
             print
----

----
Out[31]: 1 2 3 4 5 6 7 8
         9 10 11 12 13 14 15 16
         17 18 19 20 21 22 23 24
         25 26 27 28 29 30 31 32
         33 34 35 36 37 38 39 40
         41 42 43 44 45 46 47 48
         49 50 51 52 53 54 55 56
         57 58 59 60 61 62 63 64
         
----

// code cell end


==== Using OpenPyxl

(((spreadsheets, OpenPyxl library for)))(((OpenPyxl library)))(((workbooks, OpenPyxl library for)))There is yet another library to generate and read +Excel+ spreadsheet files in +.xlsx+ format with ++Python++: http://openpyxl.readthedocs.org[+OpenPyxl+]. This library allows us to both create spreadsheet files and read from them. In addition, while basic usage is similar to the other libraries, the interface is in some cases a bit more +Pythonic+ and might therefore be worth taking a look at. Import the library as follows:

// code cell start uuid: c8a07efa-bac1-4291-84d4-09646c645d3c
[source, python]
----
In [32]: import openpyxl as oxl
----

// code cell end

Let us proceed as before. First, generate a +Workbook+ object:

// code cell start uuid: 1dbe5488-9d7a-4b81-afa5-b089896590d1
[source, python]
----
In [33]: wb = oxl.Workbook()
----

// code cell end

Second, create a +Worksheet+ object:

// code cell start uuid: e6f8e75c-c9d4-4b1f-9dcd-283f2520b398
[source, python]
----
In [34]: ws = wb.create_sheet(index=0, title='oxl_sheet')
----

// code cell end

Third, write the data to the worksheet:

// code cell start uuid: 90ebe04d-4e8c-4128-a1a2-50b8466f8d44
[source, python]
----
In [35]: for c in range(data.shape[0]):
             for r in range(data.shape[1]):
                 ws.cell(row=r, column=c).value = data[c, r]
                 # creates a Cell object and assigns a value
----

// code cell end

Fourth, close the file object:

// code cell start uuid: 2ffee32b-6b71-429f-a2e6-41039be7f08f
[source, python]
----
In [36]: wb.save(path + 'oxl_book.xlsx')
----

// code cell end

With +OpenPyxl+, you can also read workbooks:

// code cell start uuid: b5c30786-7fdd-4ea2-b3dc-0156d3222988
[source, python]
----
In [37]: wb = oxl.load_workbook(path + 'oxl_book.xlsx')
----

// code cell end

Now, single cells are easily accessed via their cell names:

// code cell start uuid: 42afcab1-8ddc-4352-8525-e5c18e981998
[source, python]
----
In [38]: ws = wb.get_active_sheet()
----

// code cell end

// code cell start uuid: 529d482b-7bf7-4236-ae6e-288ba9e2c69c
[source, python]
----
In [39]: cell = ws['B4']
----

// code cell end

// code cell start uuid: 1696a7ca-dc6d-4d59-bde7-aeeca10a6671
[source, python]
----
In [40]: cell.column
----

----
Out[40]: 'B'
----

// code cell end

// code cell start uuid: 5ec00802-cb6c-4d7a-be3c-5553e879a409
[source, python]
----
In [41]: cell.row
----

----
Out[41]: 4
----

// code cell end

// code cell start uuid: 34d6d76a-a761-40e6-b10b-e553e50e76c5
[source, python]
----
In [42]: cell.value
----

----
Out[42]: 12
----

// code cell end

Similarly, you can access cell ranges as in ++Excel++:

// code cell start uuid: dd2ad818-070f-4b18-b5f3-c3a67d9ab06a
[source, python]
----
In [43]: ws['B1':'B4']
----

----
Out[43]: ((<Cell oxl_sheet.B1>,),
          (<Cell oxl_sheet.B2>,),
          (<Cell oxl_sheet.B3>,),
          (<Cell oxl_sheet.B4>,))
----

// code cell end

// code cell start uuid: 5b08db4f-cbc5-4754-8f1a-704be0ab11cd
[source, python]
----
In [44]: for cell in ws['B1':'B4']:
             print cell[0].value
----

----
Out[44]: 9
         10
         11
         12
         
----

// code cell end

There is also a +range+ method to which you can provide the cell range in +Excel+ syntax as a string:

// code cell start uuid: 6e7f8c39-310b-4ad8-adcb-a2be8918d0df
[source, python]
----
In [45]: ws.range('B1:C4')
           # same as ws['B1':'C4']
----

----
Out[45]: ((<Cell oxl_sheet.B1>, <Cell oxl_sheet.C1>),
          (<Cell oxl_sheet.B2>, <Cell oxl_sheet.C2>),
          (<Cell oxl_sheet.B3>, <Cell oxl_sheet.C3>),
          (<Cell oxl_sheet.B4>, <Cell oxl_sheet.C4>))
----

// code cell end

// code cell start uuid: 83fd28b6-5842-4b06-be98-15c1c6bcdce9
[source, python]
----
In [46]: for row in ws.range('B1:C4'):
             for cell in row:
                 print cell.value,
             print
----

----
Out[46]: 9 17
         10 18
         11 19
         12 20
         
----

// code cell end

Refer to the http://pythonhosted.org/openpyxl/[library's website] for more details.


==== Using pandas for Reading and Writing

(((spreadsheets, reading/writing with pandas)))(((pandas library, reading/writing spreadsheets with)))(((workbooks, pandas generated)))<<input_output>> shows how to interact with +Excel+ spreadsheet files using the +pandas+ library. Let us use these approaches to read the data written with the +xlwt+ library. We need a +DataFrame+ object for each sheet. With +header=None+, +pandas+ does not interpret the first data row as the header for the data set:

// code cell start uuid: d2a24b4b-9218-4887-9923-7fbe55342a1e
[source, python]
----
In [47]: df_1 = pd.read_excel(path + 'workbook.xlsx',
                              'first_sheet', header=None)
         df_2 = pd.read_excel(path + 'workbook.xlsx',
                              'second_sheet', header=None)
----

// code cell end

To recover the column names/values of the spreadsheet file, let us generate a list with capital letters as column names for the +DataFrame+ objects:

// code cell start uuid: 9119b6ba-6043-4db5-bac9-58498af778b3
[source, python]
----
In [48]: import string
         columns = []
         for c in range(data.shape[0]):
             columns.append(string.uppercase[c])
         columns
----

----
Out[48]: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']
----

// code cell end

We pass this list as the new column names to the two objects:

// code cell start uuid: fa4699d4-3e2b-448f-b5b4-10770cc0dfff
[source, python]
----
In [49]: df_1.columns = columns
         df_2.columns = columns
----

// code cell end

Indeed, the output of the two +DataFrame+ objects now resembles the spreadsheet style pretty well:

// code cell start uuid: b0dbcfe3-c903-4f7a-827b-60080f490047
[source, python]
----
In [50]: df_1
----

----
Out[50]:    A   B   C   D   E   F   G   H
         0  1   9  17  25  33  41  49  57
         1  2  10  18  26  34  42  50  58
         2  3  11  19  27  35  43  51  59
         3  4  12  20  28  36  44  52  60
         4  5  13  21  29  37  45  53  61
         5  6  14  22  30  38  46  54  62
         6  7  15  23  31  39  47  55  63
         7  8  16  24  32  40  48  56  64
----

// code cell end

// code cell start uuid: d9444f00-f215-4775-bc3e-542afdde318f
[source, python]
----
In [51]: df_2
----

----
Out[51]:     A   B   C   D   E   F   G   H
         0   1   2   3   4   5   6   7   8
         1   9  10  11  12  13  14  15  16
         2  17  18  19  20  21  22  23  24
         3  25  26  27  28  29  30  31  32
         4  33  34  35  36  37  38  39  40
         5  41  42  43  44  45  46  47  48
         6  49  50  51  52  53  54  55  56
         7  57  58  59  60  61  62  63  64
----

// code cell end

Similarly, +pandas+ allows us to write the data to +Excel+ spreadsheet files:

// code cell start uuid: 6f15f0c8-9fbd-42d4-825c-464d52ef5691
[source, python]
----
In [52]: df_1.to_excel(path + 'new_book_1.xlsx', 'my_sheet')
----

// code cell end

Note that when writing +DataFrame+ objects to spreadsheet files +pandas+ adds both column names and index values, as seen in <<excel_3>>.

Of course, +pandas+-generated +Excel+ workbooks can be read as before with the +xlrd+ library:

// code cell start uuid: 90b1de7b-b4d8-4e14-a8e6-43801c0bcde8
[source, python]
----
In [53]: wbn = xlrd.open_workbook(path + 'new_book_1.xlsx')
----

// code cell end

// code cell start uuid: 207f983b-7e03-45bd-8ab7-93a27676080c
[source, python]
----
In [54]: wbn.sheet_names()
----

----
Out[54]: [u'my_sheet']
----

// code cell end

To write multiple +DataFrame+ objects to a single spreadsheet file, one needs an +ExcelWriter+ object:

// code cell start uuid: 62892699-6d38-40f1-9713-21a0ae5b5f99
[source, python]
----
In [55]: wbw = pd.ExcelWriter(path + 'new_book_2.xlsx')
         df_1.to_excel(wbw, 'first_sheet')
         df_2.to_excel(wbw, 'second_sheet')
         wbw.save()
----

// code cell end

Let us inspect if we indeed have generated the two sheets in the single spreadsheet file:

// code cell start uuid: f4823555-b6e4-4e10-b901-a4039a136e10
[source, python]
----
In [56]: wbn = xlrd.open_workbook(path + 'new_book_2.xlsx')
----

// code cell end

// code cell start uuid: 0bc67f46-4ca2-4f06-a390-556e4f569597
[source, python]
----
In [57]: wbn.sheet_names()
----

----
Out[57]: [u'first_sheet', u'second_sheet']
----

// code cell end

[[excel_3]]
.Screenshot of workbook in Excel written with pandas
image::images/pyfi_1203.png[]

As a final use case for +pandas+ and ++Excel++, consider the reading and writing of larger amounts of data. Although this is not a fast operation, it might be useful in some circumstances. First, the sample data to be used:

// code cell start uuid: 507f4025-88a2-4bb4-98a8-00e7c5724c8e
[source, python]
----
In [58]: data = np.random.rand(20, 100000)
----

// code cell end

// code cell start uuid: 5d116207-5ed9-4a91-b0c9-ebcf362f01e4
[source, python]
----
In [59]: data.nbytes
----

----
Out[59]: 16000000
----

// code cell end

Second, generate a +DataFrame+ object out of the sample data:

// code cell start uuid: 7ec20d92-67a7-4cf8-bd9a-8b081990609a
[source, python]
----
In [60]: df = pd.DataFrame(data)
----

// code cell end

Third, write it as an +Excel+ file to the disk:

// code cell start uuid: b2c3f25b-0a7d-4495-9cfa-4c6df46c8e69
[source, python]
----
In [61]: %time df.to_excel(path + 'data.xlsx', 'data_sheet')
----

----
Out[61]: CPU times: user 1min 25s, sys: 460 ms, total: 1min 26s
         Wall time: 1min 25s
         
----

// code cell end

This takes quite a while. For comparison, see how fast native storage of the +NumPy+ +ndarray+ object is (on an SSD drive):

// code cell start uuid: a03f11b2-350b-4959-94e6-5196ba2a94ab
[source, python]
----
In [62]: %time np.save(path + 'data', data)
----

----
Out[62]: CPU times: user 8 ms, sys: 20 ms, total: 28 ms
         Wall time: 159 ms
         
----

// code cell end

// code cell start uuid: 6b2c8cf0-987e-43bc-98cc-5ad1a62e430f
[source, python]
----
In [63]: ll $path*
----

----
Out[63]: -rw------- 1 yhilpisch     7372 Sep 28 18:18 data/chart.xlsx
         -rw------- 1 yhilpisch 16000080 Sep 28 18:20 data/data.npy
         -rw------- 1 yhilpisch  3948600 Sep 28 18:20 data/data.xlsx
         -rw------- 1 yhilpisch     5828 Sep 28 18:18 data/new_book_1.xlsx
         -rw------- 1 yhilpisch     6688 Sep 28 18:18 data/new_book_2.xlsx
         -rw------- 1 yhilpisch     6079 Sep 28 18:18 data/oxl_book.xlsx
         -rw------- 1 yhilpisch     5632 Sep 28 18:18 data/workbook.xls
         -rw------- 1 yhilpisch     6049 Sep 28 18:18 data/workbook.xlsx
         
----

// code cell end

Fourth, read it from disk. This is significantly faster than writing it:

// code cell start uuid: 1309c082-6a6b-495b-b0e7-031507b15ad5
[source, python]
----
In [64]: %time df = pd.read_excel(path + 'data.xlsx', 'data_sheet')
----

----
Out[64]: CPU times: user 6.53 s, sys: 44 ms, total: 6.58 s
         Wall time: 6.51 s
         
----

// code cell end

(((range="endofrange", startref="ix_Espread")))However, see again the speed difference compared to native storage:

// code cell start uuid: 2555b0d4-fca4-45c1-9a29-0386dca800c5
[source, python]
----
In [65]: %time data = np.load(path + 'data.npy')
----

----
Out[65]: CPU times: user 16 ms, sys: 8 ms, total: 24 ms
         Wall time: 40.5 ms
         
----

// code cell end

// code cell start uuid: 5b4fc67c-8920-4a79-9935-d802d1c51d2b
[source, python]
----
In [66]: data, df = 0.0, 0.0
         !rm $path*
----

// code cell end


=== Scripting Excel with Python

((("Excel", "scripting with Python", id="ix_Epyth", range="startofrange")))The previous section shows how to generate, read, and manipulate +Excel+ spreadsheet files (i.e., workbooks). Although there are some beneficial use cases, +Python+ is not the only way, and sometimes also not the best way, to achieve the results presented there.

(((DataNitro, benefits of)))Much more interesting is to expose the analytical power of +Python+ to +Excel+ spreadsheets. However, this is a technically more demanding task. For example, the +Python+ library http://www.pyxll.com[+PyXLL+] provides means to expose +Python+ functions via so-called ++Excel++ _add-ins_, Microsoft's technology to enhance the functionality of +Excel+. Additionally, the company DataNitro provides a solution that allows the full integration of +Python+ and +Excel+ and makes +Python+ a full substitute for +VBA+ programming. Both solutions, however, are commercial products that need to be licensed.

In what follows, we provide an overview of how to use ++DataNitro++ for +Excel+ scripting, since this is a rather flexible approach to integrating +Python+ with +Excel+.


==== Installing DataNitro

(((DataNitro, installing)))++DataNitro++ works on Windows operating systems and +Excel+ installations only. On ++Mac++ OS systems it can be used in a Windows virtual machine environment. It is compatible with Office 2007 and higher. Refer to the website http://www.datanitro.com[] for further instructions on how to get a (trial) license for the solution and how to install it.

When installing ++DataNitro++ you have the option to install +Python+ as well. However, if you have already installed +Anaconda+ (cf. <<infrastructure>>), for example, there is no need to install another +Python+ version or distribution. You then just have to customize the ++DataNitro++ solution (via the +Settings+ menu) to use the existing +Anaconda+ installation. ++DataNitro++ works with all +Python+ versions +2.6+ and higher as well as with versions +3.x+.

If successfully installed, you then find the ++DataNitro++ ribbon within +Excel+, as displayed in <<excel_4>>.

[[excel_4]]
.Screenshot of Excel with DataNitro ribbon
image::images/pyfi_1204.png[]


==== Working with DataNitro

(((DataNitro, combining with Excel)))There are two main methods to combine ++DataNitro++ with ++Excel++:

Scripting:: 
    With this method, you control +Excel+ spreadsheets via +Python+ 
    scripts, similar to the approach presented in the previous section.
User-defined functions:: 
    Using this approach, you expose your own +Python+ functions to +Excel+ 
    in such a way that they can be called from within ++Excel++.

Both methods need an installation of the ++DataNitro++ solution to work—i.e., you cannot distribute something that you have worked on to somebody else who does not have the ++DataNitro++ solution installed.


===== Scripting with DataNitro

(((DataNitro, scripting with)))Open the previously generated spreadsheet file +workbook.xlsx+ in +Excel+. We want to work with ++DataNitro++ and this particular file. When you then click on the +Python Shell+ symbol in the ++DataNitro++ ribbon, your screen should look like <<excel_5>>.

[[excel_5]]
.Screenshot of Excel with DataNitro IPython shell
image::images/pyfi_1205.png[]

A simple session could then look like the following:

[source, python]
----
In [1]: Cell("B1")
Out[1]: B1

In [2]: Cell("B1").value
Out[2]: 9

In [3]: Cell("B1").value = 'Excel with Python'
  # this immediately changes the (displayed) value
  # in the spreadsheet

In [4]: Cell("B1").value
Out[4]: u'Excel with Python'
----

In the same way as you change the +value+ attribute of a +Cell+ object, you can assign a formula to it:

[source, python]
----
In [5]: Cell("A9").formula = '=Sum(A1:A8)'

In [6]: Cell("A9").value
Out[6]: 36
----

(((DataNitro, cell attributes)))(((cells, in DataNitro)))<<cell_attributes>> lists the attributes of the ++DataNitro++ +Cell+ object.

[[cell_attributes]]
.DataNitro Cell attributes
[options="header, unbreakable"]
|=======
|Attribute 	           | Description
|+row+       | Row of the cell
|+col+       | Column of the cell
|+position+  |  Position as a ++(++__++row++__++,++ __++col++__++)++ tuple
|+sheet+     | Name of the sheet the cell is in
|+name+      | Name of the cell in +Excel+ fashion
|+value+      | Value of the cell
|+vertical+   | All cell values including and below the cell
|+vertical_range+   | +Excel+ range for all cells including and below the cell
|+horizontal+       | All cell values including and right of the cell
|+horizontal_range+ | +Excel+ range for all cells including and right of the cell
|+table+         | All values including and below/right of the cell as nested ++list++ object
|+table_range+   | +Excel+ range for +table+ object
|+formula+       | +Excel+ formula
|+comment+       | Comment attached to cell
|+hyperlink+     | Hyperlink or email address as +string+ object
|+alignment+     | Text/value alignment for display
|+color+         | Cell color
|+df+   | Lets you write a +pandas+ +DataFrame+ object directly to the spreadsheet
|=======

<<cell_style>> shows typesetting options for the +Cell+ object. All options are attributes of the +font+ object, which is a property of the +Cell+ object. For example, this:

----
Cell("A1").font.size = 15
----

(((DataNitro, cell typesetting options)))sets a (new) font size.

[[cell_style]]
.DataNitro Cell typesetting options
[options="header, unbreakable"]
|=======
|Attribute 	           | Description
|+size+       | Font size
|+color+  |  Font color
|+bold+     | Bold font via +Cell("A1").font.bold=True+
|+italic+      | Italic font
|+underline+      | Underlines text
|+strikethrough+   | Puts strikethrough line through text
|+subscript+   | Subscripts text
|+superscript+       | Superscripts text
|=======

(((DataNitro, cell methods)))Finally, there are also a couple of methods for the +Cell+ object. They are listed in <<cell_methods>>.

[[cell_methods]]
.DataNitro Cell methods
[options="header, unbreakable"]
|=======
|Attribute 	           | Description
|+clear+       | Resets all properties/attributes of the cell
|+copy_from+  |  Copies all properties/attributes from another cell
|+copy_format_from+     | Copies all properties/attributes from another cell except +value+ and +formula+
|+is_empty+      | Returns +True+ if empty
|+offset+      | Returns cell object given relative offset as ++(++__++row++__++,++ __++col++__++)++ tuple
|+subtraction+      | Subtraction gives the offset; e.g., +Cell("B4") - Cell("A2")+ gives +(2, 1)+
|+print+   | Gives +name+ and +sheet+ of cell
|+set_name+   | Sets  named range in +Excel+; e.g., +Cell("A1").set_name("upper_left")+
|=======

Often, it is helpful to work with +CellRange+ instead of +Cell+ objects only. One can think of this as an approach to vectorize certain operations on multiple +Cell+ objects. Consider the following examples, still based on the same spreadsheet file +workbook.xlsx+ with our previous changes:

[source, python]
----
In [6]: CellRange("A1:A8").value
Out[6]: [1, 2, 3, 4, 5, 6, 7, 8]

In [7]: CellRange("A1:A8").value = 1
  # like broadcasting

In [8]: CellRange("A1:A8").value
Out[8]: [1, 1, 1, 1, 1, 1, 1, 1]

In [9]: CellRange("A1:A8").value = 2 * [1, 2, 3, 4]

In [10]: CellRange("A1:A8").value
Out[10]: [1, 2, 3, 4, 1, 2, 3, 4]

In [11]: Cell("A9").value
Out[11]: 20
  # value of Sum function is
  # automatically updated
----

Of course, you can also use +CellRange+ for iteration:

[source, python]
----
In [12]: for cell in CellRange("A1:B2"):
   ....:     print cell.name, cell.value
   ....:
A1 1
B1 Python with Excel
A2 2
B2 10
----

The majority of the +Cell+ attributes and methods can also be used with +CellRange+.

(((DataNitro, optimizing performance)))When writing complex +Python+ scripts for interaction with +Excel+ spreadsheets, _performance_ might be an issue. Basically, performance is bound by +Excel+ input/output (I/O) speed. The following rules should be followed whenever possible:

Reading/writing:: 
    Do not alternate reading with writing operations, since this might lower     
    performance significantly.
Vectorization:: 
    Use +CellRange+ objects or +Cell().table+ objects to read and write     
    data in (large) blocks instead of loops.footnote:[Cf. 
    <<data_structures>> for a similar discussion in the context of +NumPy+ 
    +ndarray+ objects and the benefits of vectorization. The rule of thumb 
    there as well as here is to avoid loops on the +Python+ level.]
Use +Python+:: 
    For example, when you have to transform a data block, it is better to     
    read it in total with +Python+, to manipulate it with +Python+, and to     
    write it back to the spreadsheet as a block; cell-by-cell operations     
    can be really slow.
Store data in +Python+:: 
    Store values in +Python+ when possible rather than rereading them,         
    especially for performance-critical loops or similar operations.

See the relevant sections in the ++DataNitro++ documentation for details on how to work with whole http://datanitro.com/docs/sheets.html[+Worksheet+] and http://datanitro.com/docs/workbook.html[+Workbook+] objects.


===== Plotting with DataNitro

(((DataNitro, plotting with)))A special topic when scripting +Excel+ spreadsheets with ++DataNitro++ is plotting data contained in a spreadsheet with +Python+ instead of using ++Excel++'s plotting capabilities. <<dn_plotting>> shows a +Python+ script that is only executable if ++DataNitro++ is installed. It retrieves Apple Inc. stock price data with the +DataReader+ function from +pandas+ (cf. <<fin_time_series>>), writes the data to a newly generated +Workbook+ object, and then plots the data stored in the respective +Worksheet+ object with ++Python++—i.e., with the help of ++DataNitro++'s +matplotlib.pyplot+ wrapper ++nitroplot++—and exposes the result to the spreadsheet.

[[dn_plotting]]
.Plotting data stored in a spreadsheet with DataNitro and displaying a matplotlib plot in the same spreadsheet
====
[source, python]
----
include::python/excel/dn_plotting.py[]
----
====

From a ++DataNitro++ +IPython+ shell, execute the script with:

[source, python]
----
In [1]: %run dn_plotting.py
----

If the script is successfully executed, the workbook/worksheet in +Excel+ should look as displayed in <<excel_6>>.

[[excel_6]]
.Screenshot of Excel with DataNitro plot of Apple stock price data
image::images/pyfi_1206.png[]


===== User-defined functions

(((DataNitro, user-defined functions)))((("user-defined functions (UDF)")))From a finance point of view, it seems most interesting to expose user-defined functions (UDFs) via ++DataNitro++ to +Excel+. This option has to be enabled in the +Settings+ menu of ++DataNitro++. Once this is enabled, you can import a +Python+ script with ++DataNitro++ called +functions.py+. All +Python+ functions included in this file--and they have to be in this particular file--will then be directly callable from +Excel+. Consider the by now well-known function to value European call options in the Black-Scholes-Merton model in <<functions_py>>.

[[functions_py]]
.Python script for import with DataNitro into Excel
====
[source, python]
----
include::python/excel/functions.py[]
----
====

If this script is imported via ++DataNitro++, with UDFs enabled, you can use the valuation formula from +Excel+. In practice, you can then type the following into an +Excel+ cell:

----
= bsm_call_value(B1, 100, 2.0, B4, B5)
----

This is the same then as with any other +Excel+ formula. For example, have a look at <<excel_7>>. In the upper-left corner you see a parameterization of the Black-Scholes-Merton model. When you click on +Insert Function+ in the +FORMULAS+ tab of Excel, you can enter a function dialog for the option valuation formula from +Python+ (you find it under ++DataNitro functions++). Once you have provided references to the cells containing the single parameter values, +Python+ calculates the option value and returns the result to +Excel+.

[[excel_7]]
.Screenshot of Excel function dialog for Python function
image::images/pyfi_1207.png[]

Although this function is not that computationally demanding, it illustrates how to harness the analytical power of +Python+ from +Excel+ and how to expose the results directly to +Excel+ (cells). Similarly, see <<excel_8>>. Here, we use a parameter grid to calculate multiple option values at once. The formula in cell +D11+ then takes on the form:

----
= bsm_call_value($B$1, $A11, D$8, $B$4, $B$5)
----

[[excel_8]]
.Screenshot of Excel with parameter grid for European option values
image::images/pyfi_1208.png[]

(((range="endofrange", startref="ix_Epyth")))Whereas in a previous example we plotted data contained in an +Excel+ spreadsheet, we can now also plot data generated with +Python+ in our spreadsheet. <<excel_9>> shows a 3D plot generated with +Excel+ for the European option value surface.

[[excel_9]]
.Screenshot of Excel with European option value surface plot
image::images/pyfi_1209.png[]


=== xlwings

(((Excel, integration with xlwings)))(((xlwings library)))At the time of this writing, a new contender in the +Python-Excel+ integration world has emerged: http://www.xlwings.org[+xlwings+]. +xlwings+ provides almost all the functionality for interacting with and scripting +Excel+ spreadsheets with +Python+. It is, in contrast to the ++DataNitro++ solution, an open source library and can be freely shipped with any spreadsheet. The receiver of an +xlwings+ "powered" spreadsheet only needs a (minimal) +Python+ installation. One advantage of +xlwings+ is that it works with +Excel+ both on Windows and Apple/Mac operating systems. In addition, it is well documented, although it is only in early release (0.3 at the time of this writing). The whole solution and approach look promising. and anybody interested in integrating +Python+ and +Excel+ should give it a try.


=== Conclusions

There are several options to integrate +Python+ with +Excel+. Some +Python+ libraries--like +xlwt+ or ++xlsxwriter++—allow the creation of +Excel+ spreadsheets. Other libraries like +xlrd+ allow the reading of arbitrary spreadsheet files, or they allow both reading and writing of spreadsheet files.

+pandas+ is, at least for some tasks, also helpful. For example, it is useful when it comes to writing larger data sets to a spreadsheet file or when it comes to reading data stored in such a file format.

The most powerful solution, however, at the time of this writing is the one by ++DataNitro++ that offers a tight integration of both worlds. It has similar (or even better) spreadsheet manipulation capabilities than other libraries. In addition, ++DataNitro++ allows us, for example, to expose +Python+ plots to +Excel+ spreadsheets. More importantly, it allows us to define user-defined +Python+ functions (UDFs) for usage with +Excel+ that are callable in the same way as +Excel+'s built-in functions are. ++xlwings++, a new, open source library that has been made available recently, is similar in scope and capabilities to the ++DataNitro++ solution.

In particular, the ++DataNitro++ and +xlwings+ approaches allow us to use +Excel+ as a flexible and powerful general GUI--available on almost every computer in the finance pass:[<phrase role="keep-together">industry—</phrase>]and combine it with the analytical capabilities of +Python+. The best of both worlds, so to say.


=== Further Reading

For all libraries and solutions presented in this chapter, there are helpful web resources available:

* For +xlrd+ and +xlwt+, see http://www.python-excel.org[] for the online documentation; there is also a tutorial available in +PDF+ format at http://www.simplistix.co.uk/presentations/python-excel.pdf[].
* +xlsxwriter+ is nicely documented on the website http://xlsxwriter.readthedocs.org[].
* +OpenPyxl+ has its home here: http://pythonhosted.org/openpyxl/[].
* For detailed information about ++PyXLL++, see https://www.pyxll.com[].
* Free trials and detailed documentation for ++DataNitro++ can be found at http://www.datanitro.com[].
* You can find the documentation and everything else you need regarding ++xlwings++ at http://xlwings.org.