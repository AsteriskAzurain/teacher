[[web_integration]]


== Web Integration

[quote, Andrew Grove]
____
[role="align_me_right"]
I have been quoted saying that, in the future, all companies will be pass:[<phrase role="keep-together">Internet companies. I still believe that. More than ever, really</phrase>].
____

((("web technologies", "role in finance")))(((finance, role of web technologies in)))The _Internet_, or the _Web_, has evolved from some separate world into something that is everywhere and in everything. It has become a technology platform enabling a multitude of different use cases. From a finance perspective, the following seem particularly noteworthy:

Data provision/gathering:: 
    (((data, provision/gathering with web technology)))Web technology allows the provision of data and the gathering thereof 
    in a simplified manner and generally at reduced costs; it also speeds 
    up in general all associated processes. Large financial data providers, 
    like Bloomberg and Thomson Reuters, rely heavily on the Web and related 
    technologies to provide the financial world with data in real time.
Trading/buying/selling:: 
    Using the Web also facilitates trading of financial securities; even 
    private investors today have access to professional trading facilities 
    (e.g., online brokers like Interactive Brokers) and can trade 
    securities in real time.
Application providing:: 
    ((("Software-as-a-Service (SaaS)")))Models like Software-as-a-Service (SaaS) allow both small companies,     
    like startups, and large ones to provide applications in an efficient 
    manner; even the smallest outfit can today reach a global target 
    audience at very little cost. Large corporations benefit from web 
    technologies, for example, when they use them to provide internal applications that are accessible and usable via any standard web browser, 
    instead of installing such applications on hundreds or even thousands 
    of different pass:[<phrase role="keep-together">machines</phrase>].
Communication:: 
    Of course, the Web facilitates communication within organizations and 
    across organizations; the majority of today's business and financial 
    communication has moved from paper to the Web.
Commoditization/scalability:: 
    Recent web technologies also allow for better virtualization, making 
    web servers and servers in general a commodity that everybody can rent 
    at rather low variable costs and that is easily scalable when 
    requirements change; computing power and storage capacity become more 
    and more comparable to electricity, which we are all used to getting 
    from the plug sockets at home.

(((Python, benefits for finance)))Again, +Python+ for the Web is a broad topic in itself that cannot be covered by a single chapter in this book. However, this chapter is able to cover a number of important topics from a finance perspective. In particular, it covers:

Web protocols:: 
    The first section shows how to transfer files via +FTP+ and how to 
    access websites via +HTTP+.
Web plotting:: 
    Web technologies generally allow for better interactivity and for 
    better real-time support than standard approaches, for example, for 
    plotting data; the second section introduces the plotting library 
    +Bokeh+ to generate interactive web plots and to realize real-time 
    plotting of financial data.
Web applications:: 
    One of +Python+'s strengths is its powerful web frameworks to develop 
    web-based applications; one that is really +Pythonic+ and that has     
    become quite popular recently is +Flask+. This chapter illustrates 
    techniques for developing web-based applications using this framework.
Web services:: 
    Web services have become an important aspect of web-enabled 
    applications; the last section shows how to develop a simple web 
    service for the valuation of European options on the VSTOXX volatility 
    index.


=== Web Basics

((("web technologies", "communication protocols", id="ix_WTcom", range="startofrange")))(((communication protocols, file transfer protocol)))(((ftplib library)))(((file transfer protocol)))This section gives a rather brief overview of selected +Python+ libraries for working with web technologies and protocols. Several topics, like the handling of email functionality with +Python+, are not touched upon.


==== ftplib

The ++File Transfer Protocol++ (++FTP++) is, as the name suggests, a protocol to transfer files over the Web.footnote:[For details and background refer to http://en.wikipedia.org/wiki/Ftp[].] +Python+ provides a dedicated library to work with +FTP+ called http://docs.python.org/2/library/ftplib.html[+ftplib+]:

// code cell start uuid: ed06650f-c346-4211-a504-918431567c00
[source, python]
----
In [1]: import ftplib
        import numpy as np
----

// code cell end

In what follows, we will connect to an +FTP+ server, log in, transfer a file to the server, transfer it back to the local machine, and delete the file on the server. First, the connection:

// code cell start uuid: f9533953-66c8-428e-8476-fb9b5320cbc3
[source, python]
----
In [2]: ftp = ftplib.FTP('quant-platform.com')
----

// code cell end

Not every +FTP+ server is password protected, but this one is:

// code cell start uuid: 72343084-5e71-42bc-9649-acedaf9bf9b9
[source, python]
----
In [3]: ftp.login(user='python', passwd='python')
----

----
Out[3]: '230 Login successful.'
----

// code cell end

To have a file that we can transfer, we generate a +NumPy+ +ndarray+ object with some random data and save it to disk:

// code cell start uuid: bb8b9a5f-2482-4c21-bb52-c5f0c659121b
[source, python]
----
In [4]: np.save('./data/array', np.random.standard_normal((100, 100)))
----

// code cell end

For the +FTP+ file transfer to follow, we have to open the file for reading:

// code cell start uuid: 1e23d513-1cbc-4dff-87c8-35bbefd552ea
[source, python]
----
In [5]: f = open('./data/array.npy', 'r')
----

// code cell end

This open file can now be written, choosing here binary transfer, by the +STOR+ command in combination with the target filename:

// code cell start uuid: d7723e2d-8a38-4e76-b18d-47e804bbb9e5
[source, python]
----
In [6]: ftp.storbinary('STOR array.npy', f)
----

----
Out[6]: '226 Transfer complete.'
----

// code cell end

Let us have a look at the directory of the +FTP+ server. Indeed, the file was transferred:

// code cell start uuid: 2827d953-cfad-44d3-a2bf-67cf5863a1f7
[source, python]
----
In [7]: ftp.retrlines('LIST')
----

----
Out[7]: -rw-------    1 1001     1001        80080 Sep 29 11:05 array.npy
        
        '226 Directory send OK.'
----

// code cell end

The other way around is pretty similar. To retrieve a distant file and to save it to disk, we need to open a new file, this time in +write+ mode:

// code cell start uuid: 90b28799-36f2-4591-8767-d01b85322596
[source, python]
----
In [8]: f = open('./data/array_ftp.npy', 'wb').write
----

// code cell end

Again, we choose binary transfer, and we use the +RETR+ command for retrieving the file from the +FTP+ server:

// code cell start uuid: bda461e0-6d17-4011-8d12-cae2658b0938
[source, python]
----
In [9]: ftp.retrbinary('RETR array.npy', f)
----

----
Out[9]: '226 Transfer complete.'
----

// code cell end

Since we do not need the file on the server anymore, we can delete it:

// code cell start uuid: fd643a77-53a7-4b88-80a1-992d37141e1b
[source, python]
----
In [10]: ftp.delete('array.npy')
----

----
Out[10]: '250 Delete operation successful.'
----

// code cell end

// code cell start uuid: b248ab34-3f84-434b-a4cf-75d3bef1f8fe
[source, python]
----
In [11]: ftp.retrlines('LIST')
----

----
Out[11]: '226 Directory send OK.'
----

// code cell end

Finally, we should close the connection to the +FTP+ server:

// code cell start uuid: 372f7d6f-928a-436c-bf64-13b0aa994620
[source, python]
----
In [12]: ftp.close()
----

// code cell end

In the local directory there are now two files, the one that was generated locally and the one generated by retrieving the file from the server:

// code cell start uuid: a1d9022c-bd30-43e1-b3c7-95bfefe6f60e
[source, python]
----
In [13]: !ls -n ./data
----

----
<<<<<<< HEAD
Out[13]: insgesamt 156
         -rw------- 1 1000 1000 77824 Sep 15 08:14 array_ftp.npy
         -rw------- 1 1000 1000 80080 Sep 15 08:14 array.npy
=======
Out[13]: insgesamt 156
         -rw------- 1 1000 1000 77824 Sep 29 17:05 array_ftp.npy
         -rw------- 1 1000 1000 80080 Sep 29 17:05 array.npy
>>>>>>> 798603793467fffcd06a9df88edf091e339dec37
         
----

// code cell end

// code cell start uuid: ed6eb7c9-0004-42a7-b0b3-0e1aa5f27ae1
[source, python]
----
In [14]: !rm -f ./data/arr*
           # cleanup directory
----

// code cell end

(((encryption)))(((communication protocols, secure connections)))All that has happened so far was done without encryption (i.e., was fully insecure). Both login information and data were transferred in readable form. However, for most applications such operations should be encrypted so others are not able to read the data and/or steal the login information and do even worse things.

+ftplib+ can connect to +FTP+ servers securely via the function +FTP_TLS+. Once such a secure connection is established, all other operations remain the same:

// code cell start uuid: f51de772-ad07-4983-8914-d60383fc0393
[source, python]
----
In [15]: ftps = ftplib.FTP_TLS('quant-platform.com')
----

// code cell end

// code cell start uuid: 442158b0-2c8a-47f5-a60d-3019c687b196
[source, python]
----
In [16]: ftps.login(user='python', passwd='python')
----

----
Out[16]: '230 Login successful.'
----

// code cell end

// code cell start uuid: a8ab8f48-5524-423c-936f-b045ac5dc3b0
[source, python]
----
In [17]: ftps.prot_p()
----

----
Out[17]: '200 PROT now Private.'
----

// code cell end

// code cell start uuid: 80d163ef-151d-4536-8e16-7fc0774db409
[source, python]
----
In [18]: ftps.retrlines('LIST')
----

----
Out[18]: '226 Directory send OK.'
----

// code cell end

// code cell start uuid: 6cb73378-f642-4627-89a9-f6f69f076d9a
[source, python]
----
In [19]: ftps.close()
----

// code cell end


==== httplib

(((communication protocols, hypertext transfer protocol)))(((hypertext transfer protocol)))(((httplib library)))(((HTML-based web pages)))Another important protocol, if not the most important one on the Web, is the ++HyperText Transfer Protocol++ (++HTTP++).footnote:[For details and background refer to http://en.wikipedia.org/wiki/Http[].] This protocol is used whenever a (+HTML+-based) web page is displayed in the browser. The +Python+ library to work with +HTTP+ is called http://docs.python.org/2/library/httplib.html[+httplib+]:

// code cell start uuid: 0d79f4d1-5d93-4c9d-9d62-40dc4981a457
[source, python]
----
In [20]: import httplib
----

// code cell end

As with +FTP+, we first need a connection to the +HTTP+ server:

// code cell start uuid: d665bdf3-fc62-46c0-8f7f-ff125f12ca51
[source, python]
----
In [21]: http = httplib.HTTPConnection('hilpisch.com')
----

// code cell end

Once the connection is established, we can send requests, for example asking for the +index.htm+ page (file):

// code cell start uuid: 9285e3ee-2035-4816-897f-4c9e2c7c8ef0
[source, python]
----
In [22]: http.request('GET', '/index.htm')
----

// code cell end

To test whether this was successful, use the +getresponse+ method:

// code cell start uuid: 18a7deaf-ba30-440f-88e7-fd6c90245661
[source, python]
----
In [23]: resp = http.getresponse()
----

// code cell end

The returned object provides status information. Fortunately, our request was pass:[<phrase role="keep-together">successful</phrase>]:

// code cell start uuid: ca638e56-6667-4eea-af63-c2be54c86b9c
[source, python]
----
In [24]: resp.status, resp.reason
----

----
Out[24]: (200, 'OK')
----

// code cell end

Equipped with the response object, we can now read the content as follows:

// code cell start uuid: ea7a144c-81bc-4cab-9132-c70af19773d3
[source, python]
----
In [25]: content = resp.read()
         content[:100]
           # first 100 characters of the file
----

----
Out[25]: '<!doctype html>\n<html lang="en">\n\n\t<head>\n\t\t<meta charset="utf-
         8">\n\n\t\t<title>Dr. Yves J. Hilpisch \xe2\x80'
----

// code cell end

Once you have the content of a particular web page, there are many potential use cases. You might want to look up certain information, for example. You might know that you can find the email address on the page by looking for +E+ (in this very particular case). Since +content+ is a +string+ object, you can apply the +find+ method to look for ++E++:footnote:[This example is for illustration purposes only. In general, you would want to use specialized libraries such as http://lxml.de[++lxml++] or http://www.crummy.com/software/BeautifulSoup/[++Beautiful Soup++].]

// code cell start uuid: f8ca3902-3e86-4398-8aa7-e301a0706871
[source, python]
----
In [26]: index = content.find(' E ')
         index
----

----
Out[26]: 2071
----

// code cell end

Equipped with the index value for the information you are looking for, you can inspect the subsequent characters of the object:

// code cell start uuid: 4cbca133-e69f-4f1f-8378-de0a212a6fdd
[source, python]
----
In [27]: content[index:index + 29]
----

----
Out[27]: ' E contact [at] dyjh [dot] de'
----

// code cell end

Once you are finished, you should again close the connection to the server:

// code cell start uuid: e1d9bb7e-2429-4a3b-8ad2-ce8e20f398d1
[source, python]
----
In [28]: http.close()
----

// code cell end


==== urllib

(((communication protocols, uniform resource locators)))((("URLs (uniform resource locators)")))(((urllib library)))((("comma-separated value (CSV) files", "retrieving via the Web")))There is another +Python+ library that supports the use of _different_ web protocols. It is called http://docs.python.org/2/library/urllib.html[++urllib++]. There is also a related library called http://docs.python.org/2/library/urllib2.html[++urllib2++]. Both libraries are designed to work with arbitrary web resources, in the spirit of the "uniform" in +URL+ (uniform resource locator).footnote:[There are alternatives to these libraries, like http://docs.python-requests.org[+Requests+], that come with a more modern API.] A standard use case, for example, is to retrieve files, like +CSV+ data files, via the Web. Begin by importing ++urllib++:

// code cell start uuid: 7a44c652-b62f-4974-b7be-c1c708c432d2
[source, python]
----
In [29]: import urllib
----

// code cell end

The application of the library's functions resembles that of both +ftplib+ and +httplib+. Of course, we need a +URL+ representing the web resource of interest (+HTTP+ or +FTP+ server, in general). For this example, we use the +URL+ of Yahoo! Finance to retrieve stock price information in +CSV+ format:

// code cell start uuid: eeeecf85-e182-44d1-96ca-dfa7c7b770e0
[source, python]
----
In [30]: url = 'http://ichart.finance.yahoo.com/table.csv?g=d&ignore=.csv'
         url += '&s=YHOO&a=01&b=1&c=2014&d=02&e=6&f=2014'
----

// code cell end

Next, one has to establish a connection to the resource:

// code cell start uuid: d0222eb9-e696-477e-9647-adf7296153ac
[source, python]
----
In [31]: connect = urllib.urlopen(url)
----

// code cell end

With the connection established, read out the content by calling the +read+ method on the connection object:

// code cell start uuid: afb60cb7-6822-438a-81fd-43cdaca9290c
[source, python]
----
In [32]: data = connect.read()
----

// code cell end

The result in this case is historical stock price information for Yahoo! itself:

// code cell start uuid: b97fa159-af2c-4d4c-bd07-3b26e4942f86
[source, python]
----
In [33]: print data
----

----
Out[33]: Date,Open,High,Low,Close,Volume,Adj Close
         2014-03-06,39.60,39.98,39.50,39.66,10626700,39.66
         2014-03-05,39.83,40.15,39.19,39.50,12536800,39.50
         2014-03-04,38.76,39.79,38.68,39.63,16139400,39.63
         2014-03-03,37.65,38.66,37.43,38.25,14714700,38.25
         2014-02-28,38.55,39.38,38.22,38.67,16957100,38.67
         2014-02-27,37.80,38.48,37.74,38.47,15489400,38.47
         2014-02-26,37.35,38.10,37.34,37.62,15778900,37.62
         2014-02-25,37.48,37.58,37.02,37.26,9756900,37.26
         2014-02-24,37.23,37.71,36.82,37.42,15738900,37.42
         2014-02-21,37.90,37.96,37.22,37.29,12351900,37.29
         2014-02-20,37.83,38.04,37.30,37.79,11155900,37.79
         2014-02-19,38.06,38.33,37.68,37.81,15851900,37.81
         2014-02-18,38.31,38.59,38.09,38.31,12096400,38.31
         2014-02-14,38.43,38.45,38.11,38.23,9975800,38.23
         2014-02-13,37.92,38.69,37.79,38.52,12088100,38.52
         2014-02-12,38.60,38.91,38.03,38.11,14088500,38.11
         2014-02-11,38.15,38.86,38.09,38.50,18348000,38.50
         2014-02-10,38.00,38.13,37.25,37.76,17642900,37.76
         2014-02-07,36.65,37.27,36.24,37.23,16178500,37.23
         2014-02-06,35.65,36.75,35.61,36.24,14250000,36.24
         2014-02-05,35.60,35.94,34.99,35.49,14022900,35.49
         2014-02-04,35.11,35.86,34.86,35.66,21082500,35.66
         2014-02-03,35.94,36.01,34.66,34.90,22195200,34.90
         
         
----

// code cell end

The library also provides convenience functions to customize +URL+ strings. For example, you might want to be able to parameterize the symbol to look up and the starting date. To this end, define a new +URL+ string with a string replacement part where you can insert the parameters:

// code cell start uuid: 18dc3eb4-eda6-42f2-b1f8-01454b6303f1
[source, python]
----
In [34]: url = 'http://ichart.finance.yahoo.com/table.csv?g=d&ignore=.csv'
         url += '&%s'  # for replacement with parameters
         url += '&d=06&e=30&f=2014'
----

// code cell end

The function +urlencode+ takes as an argument a +Python+ dictionary with the parameter names and the values to associate:

// code cell start uuid: 92201ad4-66a0-4c39-b0e0-2ac94182dcc2
[source, python]
----
In [35]: params = urllib.urlencode({'s': 'MSFT', 'a': '05', 'b': 1, 'c': 2014})
----

// code cell end

As result, there is a +string+ object that can be inserted into the preceding +URL+ string to complete it:

// code cell start uuid: fe19bda7-77d7-40a8-8b6a-a6fbadf29223
[source, python]
----
In [36]: params
----

----
Out[36]: 'a=05&s=MSFT&b=1&c=2014'
----

// code cell end

// code cell start uuid: 3013909d-ce21-4d68-a679-f2fd91f5e104
[source, python]
----
In [37]: url % params
----

----
Out[37]: 'http://ichart.finance.yahoo.com/table.csv?g=d&ignore=.csv&a=05&s=MSFT&
         b=1&c=2014&d=06&e=30&f=2014'
----

// code cell end

Equipped with this new +URL+ string, establish a connection and read the data from the connection:

// code cell start uuid: a291f6f5-cc24-47c1-a07b-d7cf5ffbfaf1
[source, python]
----
In [38]: connect = urllib.urlopen(url % params)
----

// code cell end

// code cell start uuid: fb09a069-94f6-4175-9515-7f2758b367af
[source, python]
----
In [39]: data = connect.read()
----

// code cell end

The result again is stock price data, this time for more dates and for Microsoft:

++++
<?hard-pagebreak?>
++++

// code cell start uuid: 5d288e85-ba12-4c37-adbc-42fd8d00b7d3
[source, python]
----
In [40]: print data
----

----
Out[40]: Date,Open,High,Low,Close,Volume,Adj Close
         2014-07-30,44.07,44.10,43.29,43.58,31921400,43.31
         2014-07-29,43.91,44.09,43.64,43.89,27763100,43.62
         2014-07-28,44.36,44.51,43.93,43.97,29684200,43.70
         2014-07-25,44.30,44.66,44.30,44.50,26737700,44.22
         2014-07-24,44.93,45.00,44.32,44.40,30725300,44.12
         2014-07-23,45.45,45.45,44.62,44.87,52362900,44.59
         2014-07-22,45.00,45.15,44.59,44.83,43095800,44.55
         2014-07-21,44.56,45.16,44.22,44.84,37604400,44.56
         2014-07-18,44.65,44.84,44.25,44.69,43407500,44.41
         2014-07-17,45.45,45.71,44.25,44.53,82180300,44.25
         2014-07-16,42.51,44.31,42.48,44.08,63318000,43.81
         2014-07-15,42.33,42.47,42.03,42.45,28748700,42.19
         2014-07-14,42.22,42.45,42.04,42.14,21881100,41.88
         2014-07-11,41.70,42.09,41.48,42.09,24083000,41.83
         2014-07-10,41.37,42.00,41.05,41.69,21854700,41.43
         2014-07-09,41.98,41.99,41.53,41.67,18445900,41.41
         2014-07-08,41.87,42.00,41.61,41.78,31218200,41.52
         2014-07-07,41.75,42.12,41.71,41.99,21952400,41.73
         2014-07-03,41.91,41.99,41.56,41.80,15969300,41.54
         2014-07-02,41.73,41.90,41.53,41.90,20208100,41.64
         2014-07-01,41.86,42.15,41.69,41.87,26917000,41.61
         2014-06-30,42.17,42.21,41.70,41.70,30805500,41.44
         2014-06-27,41.61,42.29,41.51,42.25,74640000,41.99
         2014-06-26,41.93,41.94,41.43,41.72,23604400,41.46
         2014-06-25,41.70,42.05,41.46,42.03,20049100,41.77
         2014-06-24,41.83,41.94,41.56,41.75,26509100,41.49
         2014-06-23,41.73,42.00,41.69,41.99,18743900,41.73
         2014-06-20,41.45,41.83,41.38,41.68,47764900,41.42
         2014-06-19,41.57,41.77,41.33,41.51,19828200,41.25
         2014-06-18,41.61,41.74,41.18,41.65,27097000,41.39
         2014-06-17,41.29,41.91,40.34,41.68,22518600,41.42
         2014-06-16,41.04,41.61,41.04,41.50,24205300,41.24
         2014-06-13,41.10,41.57,40.86,41.23,26310000,40.97
         2014-06-12,40.81,40.88,40.29,40.58,29818900,40.33
         2014-06-11,40.93,41.07,40.77,40.86,18040000,40.61
         2014-06-10,41.03,41.16,40.86,41.11,15117700,40.85
         2014-06-09,41.39,41.48,41.02,41.27,15019200,41.01
         2014-06-06,41.48,41.66,41.24,41.48,24060500,41.22
         2014-06-05,40.59,41.25,40.40,41.21,31865200,40.95
         2014-06-04,40.21,40.37,39.86,40.32,23209000,40.07
         2014-06-03,40.60,40.68,40.25,40.29,18068900,40.04
         2014-06-02,40.95,41.09,40.68,40.79,18504300,40.54
         
         
----

// code cell end

The function +urlretrieve+ allows us to retrieve content and save it to disk in a single step, which is quite convenient in many circumstances:

// code cell start uuid: 60b60a3a-2cce-4f97-aaa7-c042f2e60279
[source, python]
----
In [41]: urllib.urlretrieve(url % params, './data/msft.csv')
----

----
Out[41]: ('./data/msft.csv', <httplib.HTTPMessage instance at 0x7f92ca59afc8>)
----

// code cell end

(((range="endofrange", startref="ix_WTcom")))A brief inspection of the content of the saved file shows that we have indeed retrieved and saved the same content as before:

// code cell start uuid: acf4d984-2ff8-4258-9a6c-87a86ee2f116
[source, python]
----
In [42]: csv = open('./data/msft.csv', 'r')
         csv.readlines()[:5]
----

----
Out[42]: ['Date,Open,High,Low,Close,Volume,Adj Close\n',
          '2014-07-30,44.07,44.10,43.29,43.58,31921400,43.31\n',
          '2014-07-29,43.91,44.09,43.64,43.89,27763100,43.62\n',
          '2014-07-28,44.36,44.51,43.93,43.97,29684200,43.70\n',
          '2014-07-25,44.30,44.66,44.30,44.50,26737700,44.22\n']
----

// code cell end

// code cell start uuid: 62d5e85b-1590-450c-9018-746e6872f1fa
[source, python]
----
In [43]: !rm -f ./data/*
----

// code cell end


=== Web Plotting

((("web technologies", "web plotting", id="ix_WTplot", range="startofrange")))(((matplotlib library,strengths of)))<<visualization>> introduces +matplotlib+, the most popular plotting library for +Python+. However, as powerful as it might be for 2D and 3D plotting, its strength lies in static plotting. In fact, +matplotlib+ is also able to generate interactive plots, e.g., with sliders for variables. But it is safe to say that this is not one of its strengths.footnote:[For more information on interactive plots with +matplotlib+, refer to the library's http://www.matplotlib.org[home page].]

This section starts with generating _static_ plots, then proceeds to _interactive_ plots to finally arrive at _real-time_ plotting.


==== Static Plots

(((data visualization, static plots)))(((static plots)))First, a brief benchmark example using the +pandas+ library based on a financial time series from the Yahoo! Finance API, as used in the previous section:

// code cell start uuid: bb617800-1dc9-4cb9-a7b7-2b8cd16cf0b2
[source, python]
----
In [44]: import numpy as np
         import pandas as pd
         %matplotlib inline
----

// code cell end

As shown in <<fin_time_series>>, using +pandas+ makes data retrieval from the Web in general quite convenient. We do not even have to use additional libraries, such as ++urllib++—almost everything happens under the hood. The following retrieves historical stock price quotes for Microsoft Inc. and stores the data in a +DataFrame+ object:

// code cell start uuid: 8e1e8943-d88d-4b61-bf19-15e55bebfb3a
[source, python]
----
In [45]: url = 'http://ichart.yahoo.com/table.csv?s=MSFT&a=0&b=1&c=2009'
         data = pd.read_csv(url, parse_dates=['Date'])
----

// code cell end

+pandas+ accepts column names as parameter values for the ++x++ and ++y++ coordinates. The result is shown in <<microsoft>>:

// code cell start uuid: ca6562c0-9932-4d5c-9811-4512e717fac3
[source, python]
----
In [46]: data.plot(x='Date', y='Close')
----

[[microsoft]]
.Historical stock prices for Microsoft since January 2009 (matplotlib)
image::images/pyfi_1401.png[]

// code cell end

((("PNG (portable network graphics) format")))Graphics and plots like <<microsoft>> can of course also be used in a web context. For example, it is straightforward to save plots generated with +matplotlib+ as files in the +PNG+ (+Portable Network Graphics+) format and to include such files in a website. However, recent web technologies typically also provide interactivity, like _panning_ or _zooming_.

(((Bokeh library, benefits of)))(((data visualization, Bokeh library for)))http://bokeh.pydata.org[++Bokeh++] is a library that explicitly aims at providing modern, interactive web-based plots to +Python+. According to its website:

[quote]
____
Bokeh is a Python interactive visualization library for large data sets that natively uses the latest web technologies. Its goal is to provide elegant, concise construction of novel graphics in the style of Protovis/D3, while delivering high-performance interactivity over large data to thin clients.
____

Three elements of this description are noteworthy:

Large data sets:: 
    It is a "plotting problem" in itself to plot large data sets. Just 
    imagine a scatter plot with 1,000,000 points--in general, large parts of 
    the information get lost; +Bokeh+ provides built-in help in this 
    regard.
Latest web technologies:: 
    In general, +JavaScript+ is the language of choice as of today when it 
    comes to web development and visualization; it underlies libraries such 
    as +D3+ (http://d3js.org[+Data-Driven Documents+]) and also 
    +Bokeh+.
High-performance interactivity:: 
    On the Web, people are used to real-time interactivity (think modern 
    browser games), which can become an issue when visualizing and 
    interacting with large data sets; +Bokeh+ also provides built-in 
    capabilities to reach this goal.

++++
<?hard-pagebreak?>
++++

(((Bokeh library, default output)))On a fundamental level, working with +Bokeh+ is not that different from working with +matplotlib+. However, the default output generally is not a standard window or, for example, an +IPython Notebook+ (which is also an option). It is a separate +HTML+ file:

// code cell start uuid: be442f01-3953-4343-b58e-b192628af852
[source, python]
----
In [47]: import bokeh.plotting as bp
----

// code cell end

// code cell start uuid: 24607239-8a56-4841-89e9-372d8fc17c6d
[source, python]
----
In [48]: bp.output_file("../images/msft_1.html", title="Bokeh Example (Static)")
         # use: bp.output_notebook("default")
         # for output within an IPython Notebook
----

// code cell end

(((Bokeh library, plotting styles)))In terms of plotting, +Bokeh+ provides a wealth of different plotting styles that are continuously enhanced. To start with the simplest one, consider the following code that generates a line plot similar to our +pandas/matplotlib+ benchmark plot. The result is shown as <<bokeh_1>>. Apart from the ++x++ and ++y++ coordinates, all other parameters are optional:

// code cell start uuid: 687bffbc-0927-4afd-8db3-850a99a81ca0
[source, python]
----
In [49]: bp.line(
             data['Date'],
                 # x coordinates
             data['Close'],
                 # y coordinates
             color='#0066cc',
                 # set a color for the line
             legend='MSFT',
                 # attach a legend label
             title='Historical Stock Quotes',
                 # plot title
             x_axis_type='datetime',
                 # datetime information on x-axis
             tools = ''
         )
         bp.show()
----

// code cell end

In the tradition of +matplotlib+, +Bokeh+ also has a http://bokeh.pydata.org/docs/gallery.html[gallery] showcasing different plot styles.

[[bokeh_1]]
.Screenshot of HTML-based Bokeh plot
image::images/pyfi_1402.png[]


==== Interactive Plots

(((data visualization, panning/zooming)))(((data visualization, interactive plots)))(((interactive web plots)))(((Bokeh library, interactive plots)))The next step is to add interactivity to the web-based plot. Available interactivity elements ("tools") include:

++pan++::
    Supports panning of the plot (like panning with a movie camera); i.e., moving the plot (including ++x++ and ++y++ coordinates) relative to the fixed plotting frame
++wheel_zoom++::
    Enables zooming into the plot by using the mouse wheel
++box_zoom++::
    Enables zooming into the plot by marking a box with the mouse
++reset++::
    Resets the original/default view of the plot
++previewsave++::
    Generates a static (bitmap) version of the plot that can be saved in +PNG+ format

The following code demonstrates adding these tools:

// code cell start uuid: a83653f0-d602-4bdb-b2ae-6379c50e6f1c
[source, python]
----
In [50]: bp.output_file("../images/msft_2.html",
                        title="Bokeh Example (Interactive)")
         bp.line(
             data['Date'],
             data['Close'],
             color='#0066cc',
             legend='MSFT',
             title='Historical Stock Quotes',
             x_axis_type = "datetime",
             tools = 'pan, wheel_zoom, box_zoom, reset, previewsave'
                 # adding a list of interactive tools
         )
         bp.show()
----

// code cell end

The output of this code is shown as <<bokeh_2>>, where the panning function is used to move the plot within the plotting frame (compare this with <<bokeh_1>>).

(((Bokeh library, stand-alone graphics files)))In principle, all the features shown so far can also be implemented by using +matplotlib+. In fact, the interactive tools shown for +Bokeh+ are available by default with +matplotlib+ when you plot into a separate window. <<mpl_window>> shows a zoomed and panned version of the +pandas+ plot in <<microsoft>> in a separate (+Python+-controlled) window. However, in contrast to +Bokeh+, +matplotlib+ cannot "export" this functionality to be included in a separate, standalone graphics file.footnote:[The majority of graphics formats +matplotlib+ can export to are static by nature (i.e., bitmaps). A counterexample is graphics in +SVG+ (+Scalable Vector Graphics+) format, which can be programmed in +JavaScript/ECMAScript+. The library's http://www.matplotlib.org[website] provides some examples of how to do this.]

[[bokeh_2]]
.Screenshot of HTML-based Bokeh plot with interactive elements
image::images/pyfi_1403.png[]

[[mpl_window]]
.Screenshot of pandas/matplotlib-based plot with interactive elements
image::images/pyfi_1404.png[]


==== Real-Time Plots

(((data visualization, real-time plots)))(((real-time plots)))(((Bokeh library, real-time plots)))The previous subsection shows how easy it is to generate interactive, web-based plots with +Bokeh+. However, +Bokeh+ shines when it comes to real-time visualization of, for example, high-frequency financial data. Therefore, this subsection contains examples for two different real-time APIs, one for FX (foreign exchange) data in +JSON+ (+JavaScript Object Notation+) format and one for intraday tick data for stock prices delivered in +CSV+ text file format. Apart from the visualization aspect, how to read out data from such APIs is also of interest.


===== Real-time FX data

(((data, real-time foreign exchange)))((("FX (foreign exchange) data")))Our first example is based on a +JSON+ API for, among others, FX rates. Some imports first:

// code cell start uuid: 9adef26f-fc9c-42f2-b203-1387c6ff0b35
[source, python]
----
In [51]: import time
         import pandas as pd
         import datetime as dt
         import requests
----

// code cell end

(((OANDA online broker)))The API we use is from http://www.oanda.com[OANDA], an FX online broker. This broker offers an API sandbox that provides random/dummy data that resembles real exchange rates. Our example is based on the EUR–USD exchange rate (cf. the http://developer.oanda.com/[API guide]):

// code cell start uuid: f8cd1e89-f329-411e-9589-79f56fae6d90
[source, python]
----
In [52]: url = 'http://api-sandbox.oanda.com/v1/prices?instruments=%s'
           # real-time FX (dummy!) data from JSON API
----

// code cell end

(((requests library)))To connect to the API we use the http://docs.python-requests.org[+requests+ library] whose aim is to improve the interface for "humans" when interacting with web pass:[<phrase role="keep-together">resources</phrase>]:

// code cell start uuid: 592c5d7c-45be-4bfd-92a1-4b0f1a80c551
[source, python]
----
In [53]: instrument = 'EUR_USD'
         api = requests.get(url % instrument)
----

// code cell end

With the open connection, data in +JSON+ format is simply read by calling the method +json+ on the connection object:

// code cell start uuid: 00638626-fea7-4e21-9f9f-0b9313000f19
[source, python]
----
In [54]: data = api.json()
         data
----

----
Out[54]: {u'prices': [{u'ask': 1.25829,
            u'bid': 1.2582,
            u'instrument': u'EUR_USD',
            u'time': u'2014-09-29T06:14:34.749878Z'}]}
----

// code cell end

Unfortunately, the data is not yet completely in the format we would like it to have. Therefore, we transform it a bit. The following code takes only the first element of the +list+ object stored under the key "prices." The resulting object is a standard +dict+ object:

// code cell start uuid: 7c95e256-1a25-4ad0-972b-b66d05a2a6ca
[source, python]
----
In [55]: data = data['prices'][0]
         data
----

----
Out[55]: {u'ask': 1.25829,
          u'bid': 1.2582,
          u'instrument': u'EUR_USD',
          u'time': u'2014-09-29T06:14:34.749878Z'}
----

// code cell end

Since we collect such small data sets at a high frequency, we use a +DataFrame+ object to store all the data. The following code initializes an appropriate +DataFrame+ object:

// code cell start uuid: 9d23fa5e-b572-4182-aca2-46f8db6f5615
[source, python]
----
In [56]: ticks = pd.DataFrame({'bid': data['bid'],
                               'ask': data['ask'],
                               'instrument': data['instrument'],
                               'time': pd.Timestamp(data['time'])},
                               index=[pd.Timestamp(data['time']),])
           # initialization of ticks DataFrame
----

// code cell end

// code cell start uuid: 012c3b07-bbab-4484-931f-68daef241186
[source, python]
----
In [57]: ticks[['ask', 'bid', 'instrument']]
----

----
Out[57]:                                       ask     bid instrument
         2014-09-29 06:14:34.749878+00:00  1.25829  1.2582    EUR_USD
----

// code cell end

Implementing a real-time plot requires two things: real-time data collection and real-time updates of the plot. With +Bokeh+, this is accomplished by using the +Bokeh+ server, which handles real-time updates of a plot given new data. It has to be started via the shell or command-line interface as follows:

----
$ bokeh-server
----

With the server running in the background, let us implement the real-time data update routine:

// code cell start uuid: 5022e534-a263-46ef-a19e-f961bb31d93d
[source, python]
----
In [58]: import bokeh.plotting as bp
         from bokeh.objects import Glyph
----

// code cell end

Before any _updating_ takes place, there needs to be an object to be updated. This again is a line plot—if only with very little data at first. The output is directed to the +IPython Notebook+ the code is executed in. However, in fact it is redirected again to the server, which in this case can be accessed locally via __http://localhost:5006/__:

// code cell start uuid: b4bb7e90-a1c6-48fa-892b-74e54d08b4b8
[source, python]
----
In [59]: bp.output_notebook("default")
         bp.line(ticks['time'], ticks['bid'],
                 x_axis_type='datetime', legend=instrument)
----

----
Out[59]: Using saved session configuration for http://localhost:5006/
         To override, pass 'load_from_config=False' to Session
         
----

----
         <bokeh.objects.Plot at 0x7fdb7e1b2e10>
----

// code cell end

We need to get access to our current plot (i.e., the most recently generated plot). Calling the function +curplot+ returns the object we are looking for:

// code cell start uuid: 55ca9d0a-577e-4763-81d5-26a56cd8bf6f
[source, python]
----
In [60]: bp.curplot()
----

----
Out[60]: <bokeh.objects.Plot at 0x7fdb7e1b2e10>
----

// code cell end

Such a +Plot+ object consists of a number of rendering objects that accomplish different plotting tasks, like plotting a +Grid+ or plotting the line (= +Glyph+) representing the financial data. All rendering objects are stored in a +list+ attribute called +renderers+:

// code cell start uuid: 48199374-97d7-42fd-a26d-b75177e3e2a7
[source, python]
----
In [61]: bp.curplot().renderers
----

----
Out[61]: [<bokeh.objects.DatetimeAxis at 0x7fdbaece6b50>,
          <bokeh.objects.Grid at 0x7fdb7e161190>,
          <bokeh.objects.LinearAxis at 0x7fdb7e161090>,
          <bokeh.objects.Grid at 0x7fdb7e1614d0>,
          <bokeh.objects.BoxSelectionOverlay at 0x7fdb7e161490>,
          <bokeh.objects.BoxSelectionOverlay at 0x7fdb7e161550>,
          <bokeh.objects.Legend at 0x7fdb7e161650>,
          <bokeh.objects.Glyph at 0x7fdb7e161610>]
----

// code cell end

The following +list+ comprehension returns the first rendering object of type +Glyph+:

// code cell start uuid: df772843-dbd2-4555-afb9-4ab1390768a5
[source, python]
----
In [62]: renderer = [r for r in bp.curplot().renderers
                     if isinstance(r, Glyph)][0]
----

// code cell end

The +glyph+ attribute of the object contains the type of the +Glyph+ object—in this case, as expected, a +Line+ object:

// code cell start uuid: 12087afa-222b-452d-b27b-18c67ddc80f4
[source, python]
----
In [63]: renderer.glyph
----

----
Out[63]: <bokeh.glyphs.Line at 0x7fdb7e161590>
----

// code cell end

With the rendering object, we can access its data source directly:

// code cell start uuid: 342a1652-410d-4560-a6a9-ef7f2b82bc95
[source, python]
----
In [64]: renderer.data_source
----

----
Out[64]: <bokeh.objects.ColumnDataSource at 0x7fdb7e1b2ed0>
----

// code cell end

// code cell start uuid: 6c936827-9d31-4dd7-996e-5876e0faf695
[source, python]
----
In [65]: renderer.data_source.data
----

----
Out[65]: {'x': 2014-09-29 06:14:34.749878+00:00    2014-09-29 06:14:34.749878+00
         :00
          Name: time, dtype: object, 'y': 2014-09-29 06:14:34.749878+00:00    1.
         2582
          Name: bid, dtype: float64}
----

// code cell end

// code cell start uuid: b28cf17a-05a8-41bc-b039-201b7f786d00
[source, python]
----
In [66]: ds = renderer.data_source
----

// code cell end

This is the object that we will work with and that is to be updated whenever new data arrives. The following +while+ loop runs for a predetermined period of time only. During the loop, a new request object is generated and the +JSON+ data is read. The new data is appended to the existing +DataFrame+ object. The ++x++ and ++y++ coordinates of the rendering object are updated and then stored to the current session:

// code cell start uuid: 55f41799-a882-4113-ab04-d46a350b6c61
[source, python]
----
In [67]: start = time.time()
         # run for 60 seconds
         while (time.time() - start) < 60:
             data = requests.get(url % instrument).json()
               # connect and read data
             data = dict(data['prices'][0])
               # transform data to dict object
             ticks = ticks.append(pd.DataFrame({'bid': data['bid'],
                                         'ask': data['ask'],
                                         'instrument': data['instrument'],
                                         'time': pd.Timestamp(data['time'])},
                                  index=[pd.Timestamp(data['time']),]))
               # append DataFrame object with new data to existing object
             ds.data['x'] = ticks['time']
               # update x coordinates in rendering object
             ds.data['y'] = ticks['bid']
               # update y coordinates in rendering object
             bp.cursession().store_objects(ds)
               # store data objects
             time.sleep(0.1)
               # wait for a bit
----

// code cell end

<<bokeh_3>> shows the output of the plotting exercise--i.e., a static snapshot of a real-time plot. This approach and the underlying technology of course have many interesting application areas, both in finance, with its focus today on real-time, high-frequency data, and far beyond.

[[bokeh_3]]
.Screenshot of real-time Bokeh plot via Bokeh Server (exchange rate)
image::images/pyfi_1405.png[]


===== Real-time stock price quotes

(((data, real-time stock price quotes)))(((real-time stock price quotes)))(((data, high-frequency)))The second example uses real-time, high-frequency stock price data. First, make sure to correctly direct the output (i.e., in this case to the ++Bokeh++ server for the real-time plot):

// code cell start uuid: 6949ad26-db49-4848-82a8-e410d6917853
[source, python]
----
In [68]: bp.output_notebook("default")
----

----
Out[68]: Using saved session configuration for http://localhost:5006/
         To override, pass 'load_from_config=False' to Session
         
----

// code cell end

<<fin_time_series>> provides an example based on the data source and API that we use in what follows. It is the stock price API for intraday real-time data provided by http://www.netfonds.no[Netfonds], a Norwegian online broker. The API and web service, respectively, have the following basic +URL+ format:

// code cell start uuid: 33bbf187-b9ea-4a56-8132-a5ba5fcfd310
[source, python]
----
In [69]: url1 = 'http://hopey.netfonds.no/posdump.php?'
         url2 = 'date=%s%s%s&paper=%s.O&csv_format=csv'
         url = url1 + url2
----

// code cell end

This +URL+ is to be customized by providing date information and the symbol one is interested in:

// code cell start uuid: 976c17f6-bc3f-4238-a121-5c8c483b685d
[source, python]
----
In [70]: today = dt.datetime.now()
         y = '%d' % today.year
           # current year
         m = '%02d' % today.month
           # current month, add leading zero if needed
         d = '%02d' % (today.day)
           # current day, add leading zero if needed
         sym = 'AAPL'
           # Apple Inc. stocks
----

// code cell end

// code cell start uuid: 51351a83-4e9d-427a-ac87-183a59d1ae19
[source, python]
----
In [71]: y, m, d, sym
----

----
Out[71]: ('2014', '09', '29', 'AAPL')
----

// code cell end

// code cell start uuid: 3e2596c2-2ea2-419c-9c0f-a525eef874d5
[source, python]
----
In [72]: urlreq = url % (y, m, d, sym)
         urlreq
----

----
Out[72]: 'http://hopey.netfonds.no/posdump.php?date=20140929&paper=AAPL.O&csv_fo
         rmat=csv'
----

// code cell end

++++
<?hard-pagebreak?>
++++

Equipped with the right +URL+ string, retrieving data is only one line of code away:

// code cell start uuid: cd2c7a3b-9a59-4a62-994e-4470cfec9011
[source, python]
----
In [73]: data = pd.read_csv(urlreq, parse_dates=['time'])
           # initialize DataFrame object
----

// code cell end

The details of what follows are known from the previous example. First, the initial plot:

// code cell start uuid: f9acc0f9-0794-4d71-b39c-25d029cfa201
[source, python]
----
In [74]: bp.line(data['time'], data['bid'],
                 x_axis_type='datetime', legend=sym)
           # intial plot
----

----
Out[74]: <bokeh.objects.Plot at 0x7f92bedc8dd0>
----

// code cell end

Second, selection of the rendering object:

// code cell start uuid: ddab6fca-38f8-4674-8c92-10c86a0db7d9
[source, python]
----
In [75]: renderer = [r for r in bp.curplot().renderers
                     if isinstance(r, Glyph)][0]
         ds = renderer.data_source
----

// code cell end

Third, the +while+ loop updating the financial data and the plot per loop:

// code cell start uuid: 100d96d2-69c7-4470-8853-b24c197f279d
[source, python]
----
In [76]: start = time.time()
         while (time.time() - start) < 60:
             data = pd.read_csv(urlreq, parse_dates=['time'])
             data = data[data['time'] > dt.datetime(int(y), int(m), int(d),
                                                    10, 0, 0)]
               # only data from trading start at 10am
             ds.data['x'] = data['time']
             ds.data['y'] = data['bid']
             ds._dirty = True
             bp.cursession().store_objects(ds)
             time.sleep(0.5)
----

// code cell end

(((range="endofrange", startref="ix_WTplot")))<<bokeh_4>> shows the resulting output--again, unfortunately, only a static snapshot of a real-time plot.

[[bokeh_4]]
.Screenshot of real-time Bokeh plot via Bokeh Server (stock quotes)
image::images/pyfi_1406.png[]


=== Rapid Web Applications

((("web technologies", "rapid web applications", id="ix_WTrapid", range="startofrange")))((("application development", "rapid web applications", id="ix_ADrapid", range="startofrange")))((("Python", "rapid web application development", id="ix_Pythrapid", range="startofrange")))If the +Python+ world were to be divided into continents, there might be, among others, the _science and finance_ content, the _system administration_ continent, and for sure the _web development_ continent. Although not really transparent, it is highly probable that the web development continent, to stay with this concept, might be one of the largest when it comes to people (developers) populating it and houses (applications) built pass:[<phrase role="keep-together">on it</phrase>].

(((rapid web application development, benefits of Python for)))One of the major reasons for +Python+ being strong in web development is the availability of different high-level, full-stack frameworks. As the http://wiki.python.org/moin/WebFrameworks[+Python+ web page] states:

[quote]
____
A web application may use a combination of a base HTTP application server, a storage mechanism such as a database, a template engine, a request dispatcher, an authentication module and an AJAX toolkit. These can be individual components or be provided together in a high-level framework.
____

(((rapid web application development, popular frameworks for)))Among the most popular frameworks are:

* http://www.djangoproject.com[++Django++]
* http://flask.pocoo.org[++Flask++]
* http://www.pylonsproject.org[++Pyramid/Pylons++]
* http://www.turbogears.org[++TurboGears++]
* http://zope2.zope.org[++Zope++]

It is safe to say that there is not a single framework that is best suited for everybody and every different application type.footnote:[See http://wiki.python.org/moin/WebFrameworks[] for further information on +Python+ web frameworks. See https://wiki.python.org/moin/ContentManagementSystems[] for an overview of content management systems (CMSs) for +Python+.] All have their strengths (and sometimes weaknesses), and often it is more a matter of taste (regarding architecture, style, syntax, APIs, etc.) what framework is chosen.

(((rapid web application development, Flask framework for)))(((Flask framework, benefits of)))One framework that has recently gained popularity quite rapidly is +Flask+. It is the framework we use here, mainly for the following reasons:

Pythonic:: 
    Application development with +Flask+ is really +Pythonic+, with a lot 
    of the web-related details being taken care of behind the scenes.
Compactness:: 
    It is not too complex and can therefore be learned quite rapidly; it is 
    based mainly on standard components and libraries widely used 
    elsewhere.
Documentation:: 
    It is well documented, with both an online +HTML+ version and a 
    +PDF+ with around 300 pages available at the time of this writing.footnote:[Although the framework is still quite recent (it all started in 2010), there are already books about +Flask+ available. Cf. Grinberg (2014).]

(((Flask framework, libraries required)))(((Jinja2 library)))(((Werkzeug library)))The two main libraries that +Flask+ relies on are:

* http://jinja.pocoo.org/docs/[++Jinja2++], a web templating language/engine for +Python+
* http://werkzeug.pocoo.org[++Werkzeug++], a +WSGI+ (+Web Server Gateway Interface+) toolkit for +Python+


==== Traders' Chat Room

(((Flask framework, traders' chat room application)))(((rapid web application development, traders' chat room)))(((traders' chat room application, basic idea of)))We will now dive into the example application called _Tradechat_ for a traders' chat room, which basically relies on the example used in the tutorial of the +Flask+ documentation but includes a couple of changes and adds some further functionality.footnote:[The example application is called https://github.com/mitsuhiko/flask/tree/master/examples/flaskr/[+Flaskr+] and represents a microblog application. Our example is, more or less, a mixture between +Flaskr+ and https://github.com/mitsuhiko/flask/tree/master/examples/minitwit[+Minitwit+], another +Flask+ example application resembling a simple Twitter clone.]

The basic idea is to build a web-based application for which traders can register that provides one central chat room to exchange ideas and talk markets. The main screen shall allow a user who is logged in to type in text that is, after pushing a button, added to the timeline, indicating who added the comment and when this happened. The main screen also shows all the historical entries in descending order (from newest to oldest).


==== Data Modeling

(((Flask framework, data modeling)))(((rapid web application development, data modeling)))(((traders' chat room application, data modeling)))We start by generating the needed directories. +tradechat+ shall be the main directory. In addition, at a minimum, we need the two subdirectories +static+ and +templates+ (by +Flask+ convention):

----
$ mkdir tradechat
$ mkdir tradechat/static
$ mkdir tradechat/templates
----

To store data--both for registered users and for comments made in the chat room--we use +SQLite3+ (cf. http://www.sqlite.org[] and http://docs.python.org/2/library/sqlite3.html[]) as a database. Two different tables are needed that can be generated by the +SQL+ schema presented in <<tables_sql>>, the details of which we do not discuss here. You should store this under the filename +tables.sql+ in the main directory of the application, +tradechat+.

[[tables_sql]]
.SQL schema to generate tables in SQLite3
====
[source, sql]
----
include::python/tradechat/tables.sql[]
----
====


==== The Python Code

(((Flask framework, importing libraries)))(((rapid web application development, importing libraries)))(((traders' chat room application, importing libraries)))The +SQL+ schema is a main input for the +Python/Flask+ application to follow. We will go through the single elements step by step to finally arrive at the complete +Python+ script to be stored under +tradechat.py+ in the main directory, +tradechat+.


===== Imports and database preliminaries

At the beginning we need to import a couple of libraries and also some main functions from +Flask+. We import the functions directly to shorten the code throughout and increase readability somewhat:

[source, python]
----
# Tradechat
#
# A simple example for a web-based chat room
# based on Flask and SQLite3.
#

import os
import datetime as dt
from sqlite3 import dbapi2 as sqlite3
from flask import Flask, request, session, g, redirect, url_for, abort, \
     render_template, flash
----

The whole application hinges on a +Flask+ object, an instance of the main class of the framework. Instantiating the class with +name+ lets the object inherit the application name (i.e., +main+) when the script is executed, for example, from a shell:

[source, python]
----
# the application object from the main Flask class
app = Flask(__name__)
----

The next step is to do some configuration for the new application object. In particular, we need to provide a database filename:

[source, python]
----
# override config from environment variable
app.config.update(dict(
    DATABASE=os.path.join(app.root_path, 'tradechat.db'),
      # the SQLite3 database file ("TC database")
    DEBUG=True,
    SECRET_KEY='secret_key',
      # use secure key here for real applications
))
app.config.from_envvar('TC_SETTINGS', silent=True)
  # do not complain if no config file exists

----

Having provided the path and filename of the database, the function +connect_db+ connects to the database and returns the connection object:

[source, python]
----
def connect_db():
    ''' Connects to the TC database.'''
    rv = sqlite3.connect(app.config['DATABASE'])
    rv.row_factory = sqlite3.Row
    return rv
----

(((Flask framework, database infrastructure)))(((rapid web application development, database infrastructure)))(((traders' chat room application, database infrastructure)))+Flask+ uses an object called +g+ to store global data and other objects. For example, web applications serving large numbers of users make it necessary to connect regularly to databases. It would be inefficient to instantiate a connection object every time a database operation has to be executed. One can rather store such a connection object in the attribute +sqlite_db+ of the +g+ object. The function +get_db+ makes use of this approach in that a _new_ database connection is opened only when there is no connection object stored in the +g+ object already:

[source, python]
----
def get_db():
    ''' Opens a new connection to the TC database. '''
    if not hasattr(g, 'sqlite_db'):
        # open only if none exists yet
        g.sqlite_db = connect_db()
    return g.sqlite_db
----

At least once, we need to create the tables in the database. Calling the function +init_db+ for a second time will delete all information previously stored in the database (according to the +SQL+ schema used):

[source, python]
----
def init_db():
    ''' Creates the TC database tables.'''
    with app.app_context():
        db = get_db()
        with app.open_resource('tables.sql', mode='r') as f:
            db.cursor().executescript(f.read())
               # creates entries and users tables
        db.commit()
----

The function +close_db+ closes the database connection if one exists in the +g+ object. For the first time (and for sure not the last time), we encounter a +Flask+ function decorator, i.e., +@app.teardown_appcontext+. This decorator ensures that the respective function is called whenever the application context tears down—that is, roughly speaking, when the execution of the application is terminated by the user or by an error/exception:

[source, python]
----
@app.teardown_appcontext
def close_db(error):
    ''' Closes the TC database at the end of the request. '''
    if hasattr(g, 'sqlite_db'):
        g.sqlite_db.close()
----


===== Core functionality

(((Flask framework, connection/log in)))(((rapid web application development, connection/log in)))(((traders' chat room application, connection/log in)))Building on the database infrastructure, we can now proceed and implement the core functionality for the application. First, we have to define what happens when we connect to the main/home page of the application. To this end, we use the +Flask+ function decorator +@app.route("/")+. The function decorated in that way will be called whenever a connection is established to the main page. The function +show_entries+ basically establishes a database connection, retrieves all comments posted so far (maybe none, maybe many), and sends them to a template-based rendering engine to return an +HTML+ document based on the template and the data provided (more on the templating pass:[<phrase role="keep-together">part soon</phrase>]):

[source, python]
----
@app.route('/')
def show_entries():
    ''' Renders all entries of the TC database. '''
    db = get_db()
    query = 'select comment, user, time from comments order by id desc'
    cursor = db.execute(query)
    comments = cursor.fetchall()
    return render_template('show_entries.html', comments=comments)
----

We only want to allow _registered_ users to post comments in the chat room. Therefore, we must provide functionality for a user to register. To this end, technically, we must allow use of the +POST+ method for the respective +HTML+ to be rendered by the application and to be accessed by the user. To register, a user must provide a _username_ and a _password_. Otherwise, an error is reported. The function +register+ should be considered a simple illustration only. It is missing a number of ingredients important for real-world applications, like checking whether a username already exists and encryption of the passwords (they are stored as plain text). Once users have successfully registered, their status is automatically changed to +logged_in+ and they are redirected to the main page via ++redirect(url_for("show_entries"))++:

[source, python]
----
@app.route('/register', methods=['GET', 'POST'])
def register():
    ''' Registers a new user in the TC database. '''
    error = None
    if request.method == 'POST':
        db = get_db()
        if request.form['username'] == '' or request.form['password'] == '':
            error = 'Provide both a username and a password.'
            # both fields have to be nonempty
        else:
            db.execute('insert into users (name, password) values (?, ?)',
                         [request.form['username'], request.form['password']])
            db.commit()
            session['logged_in'] = True
            # directly log in new user
            flash('You were sucessfully registered.')
            app.config.update(dict(USERNAME=request.form['username']))
            return redirect(url_for('show_entries'))
    return render_template('register.html', error=error)
----

For such a web application, there are probably returning users that do not need or want to reregister anew. We therefore need to provide a form to log in with an existing account. This is what the function +login+ does. The functionality is similar to that provided by +register+:

[source, python]
----
@app.route('/login', methods=['GET', 'POST'])
def login():
    ''' Logs in a user. '''
    error = None
    if request.method == 'POST':
        db = get_db()
        try:
            query = 'select id from users where name = ? and password = ?'
            id = db.execute(query, (request.form['username'],
                                    request.form['password'])).fetchone()[0]
              # fails if record with provided username and password
              # is not found
            session['logged_in'] = True
            flash('You are now logged in.')
            app.config.update(dict(USERNAME=request.form['username']))
            return redirect(url_for('show_entries'))
        except:
            error = 'User not found or wrong password.'
    return render_template('login.html', error=error)
----

(((Flask framework, commenting functionality)))(((rapid web application development, commenting functionality)))(((traders' chat room application, commenting functionality)))Once users have registered or logged in again, they should be able to add comments in the chat room. The function +add_entry+ stores the comment text, the username of the user who commented, and the exact time (to the second) of the posting. The function also checks whether the user is logged in or not:

[source, python]
----
@app.route('/add', methods=['POST'])
def add_entry():
    ''' Adds entry to the TC database. '''
    if not session.get('logged_in'):
        abort(401)
    db = get_db()
    now = dt.datetime.now()
    db.execute('insert into comments (comment, user, time) values (?, ?, ?)',
            [request.form['text'], app.config['USERNAME'], str(now)[:-7]])
    db.commit()
    flash('Your comment was successfully added.')
    return redirect(url_for('show_entries'))
----

Finally, to end the session, the user must log out. This is what the function +logout+ supports:

[source, python]
----
@app.route('/logout')
def logout():
    ''' Logs out the current user. '''
    session.pop('logged_in', None)
    flash('You were logged out')
    return redirect(url_for('show_entries'))
----

If we want to run the +Python+ script as a standalone application we should add the following lines, which make sure that a server is fired up and that the application is served:

[source, python]
----
# main routine
if __name__ == '__main__':
    init_db()  # comment out if data in current
               # TC database is to be kept
    app.run()
----

Putting all these pieces together, we end up with the +Python+ script shown as <<tradechat_py>>.

[[tradechat_py]]
.Python script embodying the core of the Tradechat application
====
[source, python]
----
include::python/tradechat/tradechat.py[]
----
====

.Security
[WARNING]
=====
(((Flask framework, security issues)))(((rapid web application development, security issues)))(((traders' chat room application, security issues)))Although the example in this section illustrates the basic design of a web application in +Python+ with +Flask+, it barely addresses security issues, which are of paramount importance when it comes to web applications. However, +Flask+ and other web frameworks provide complete tool sets to tackle typical security issues (e.g., encryption) with due diligence.
=====


==== Templating

(((Flask framework, templating in)))(((rapid web application development, templating)))(((traders' chat room application, templating)))(((templating)))Basically, templating with +Flask+ (+Jinja2+) works similarly to simple string replacements in +Python+: you have a basic +string+ indicating where to replace what and some data to be inserted into the +string+ object. Consider the following examples:

// code cell start uuid: 1463132b-34c8-4238-8d3e-6ba5c7562194
[source, python]
----
In [77]: '%d, %d, %d' % (1, 2, 3)
----

----
Out[77]: '1, 2, 3'
----

// code cell end

// code cell start uuid: c5c11d6d-ad65-4ee7-9ebe-91dc1c3d2497
[source, python]
----
In [78]: '{}, {}, {}'.format(1, 2, 3)
----

----
Out[78]: '1, 2, 3'
----

// code cell end

// code cell start uuid: 7ff70268-2c8f-45a5-a6b0-17bb9d77cc14
[source, python]
----
In [79]: '{}, {}, {}'.format(*'123')
----

----
Out[79]: '1, 2, 3'
----

// code cell end

Templating to generate +HTML+ pages works pretty similarly. The major difference is that the +string+ object "resembles" an +HTML+ document (or a part thereof) and has commands for replacements and also, for example, ways of controlling the flow when rendering the template (e.g., the +for+ loop). Missing information is added during the rendering procedure, as we added the integers to the +string+ object in the previous examples. Consider now the following +string+ object, containing partly standard +HTML+ code and some template-specific code:

// code cell start uuid: da70e7f6-9068-4039-bdfc-8bfe510a7ee6
[source, python]
----
In [80]: templ = '''<!doctype html>
           Just print out <b>numbers</b> provided to the template.
           <br><br>
           {% for number in numbers %}
             {{ number }}
           {% endfor %}
         '''
----

// code cell end

So far, this is a +string+ object only. We have to generate a +Jinja2+ +Template+ object out of it before proceeding:

// code cell start uuid: 6b66b22b-fb7f-4dc7-99f4-ed6550e9eb2f
[source, python]
----
In [81]: from jinja2 import Template
----

// code cell end

// code cell start uuid: 641a5ee8-9ef7-4e60-80cb-c73b1d81f182
[source, python]
----
In [82]: t = Template(templ)
----

// code cell end

This +Template+ object has a method called +render+ to make valid +HTML+ code out of the template and some input values—in this case, some numbers via the parameter +numbers+:

// code cell start uuid: ad91b975-9917-4d22-99db-635d745308a8
[source, python]
----
In [83]: html = t.render(numbers=range(5))
----

// code cell end

The code is again a +string+ object:

// code cell start uuid: 3ddf0465-00f2-4c70-8547-7460eba6f11d
[source, python]
----
In [84]: html
----

----
Out[84]: u'<!doctype html>\n  Just print out <b>numbers</b> provided to the temp
         late.\n  <br><br>\n  \n    0\n  \n    1\n  \n    2\n  \n    3\n  \n    
         4\n  '
----

// code cell end

Such an object containing +HTML+ code can be rendered in +IPython+ +Notebook+ as follows:

// code cell start uuid: d8d44498-a17f-41b3-9e91-6d09a288c5b8
[source, python]
----
In [85]: from IPython.display import HTML
         HTML(html)
----

----
Out[85]: <IPython.core.display.HTML at 0x7fdb7e1eb890>
----

// code cell end

Of course, templating involves much more than this simple example can illustrate (e.g., inheritance). More details can be found at http://jinja.pocoo.org[]. However, the templates for the Tradechat application already include a number of important aspects. Specifically, we need the following templates:

++layout.html++::
    Defines the basic layout from which the other templates inherit
++register.html++::
    The template for the user registration page
++login.html++::
    The corresponding template for the user login
++show_entries.html++::
    The main page showing the comments in the chat room and, if the user is logged in, the text field for writing and posting comments

These files have to be stored in +templates+, the default (sub)directory for templates when using +Flask+.

<<layout_html>> shows the template containing the basic layout and some meta-information (like the site title). This is the template all other templates inherit from.

[[layout_html]]
.Template for basic layout of Tradechat application
====
[source, html]
----
include::python/tradechat/templates/layout.html[]
----
====

<<tc_1>> shows a screenshot of the main page after starting the application for the first time. No users are registered (or logged in, of course). No comments have been posted yet.

[[tc_1]]
.Screenshot of "empty" home page of Tradechat
image::images/pyfi_1407.png[]

<<register_html>> provides the templating code for the user registration page. Here, forms are used to allow users to provide information to the page via the +POST+ method.

[[register_html]]
.Template for Tradechat user registration
====
[source, html]
----
include::python/tradechat/templates/register.html[]
----
====

<<tc_2>> shows a screenshot of the registration page.

[[tc_2]]
.Screenshot of Tradechat registration page
image::images/pyfi_1408.png[]

The templating code for the login page, as shown in <<login_html>>, is pretty similar to the code for the registration page. Again, the user can provide login information via pass:[<phrase role="keep-together">a form</phrase>].

[[login_html]]
.Template for Tradechat user login
====
[source, html]
----
include::python/tradechat/templates/login.html[]
----
====

The login page, as shown in <<tc_3>>, not only looks pretty similar to the registration page but also provides mainly the same functionality.

[[tc_3]]
.Screenshot of Tradechat login page
image::images/pyfi_1409.png[]

Finally, <<show_entries_html>> provides the templating code for the main page. This template does mainly two things:

++++
<?hard-pagebreak?>
++++

Enables commenting:: 
    If the user is logged in, a text field and a +Post+ button are shown to 
    allow the user to post comments.
Displays comments:: 
    All comments found in the database are displayed in reverse 
    chronological order (newest first, oldest last).

[[show_entries_html]]
.Template for Tradechat main page with chat room comments
====
[source, html]
----
include::python/tradechat/templates/show_entries.html[]
----
====

Once a user is logged in and has posted some comments, the main page shows the text field and the +Post+ button as well as all comments stored in the database (cf. <<tc_4>>).

Just showing the screenshots in combination with the templates is cheating, in a sense. What is missing in the mix is the styling information.

[[tc_4]]
.Screenshot of Tradechat main page
image::images/pyfi_1410.png[]


==== Styling

(((Flask framework, styling web pages in)))(((rapid web application development, styling web pages)))(((traders' chat room application, styling)))((("CSS (Cascading Style Sheets)")))Today's standard when it comes to the styling of web pages and web-based applications is +CSS+ (+Cascading Style Sheets+). If you take a closer look at the single templates, you will find in many places parameterizations like +class=comments+ or +class=add-comment+. Without a corresponding +CSS+ file, these parameterizations are essentially meaningless.

Therefore, let us have a look at the file +style.css+, stored in the (sub)directory +static+ and shown in <<style_css>>. Here you find the aforementioned parameters (+comments+, +add-comment+) again. You also find references to standard +HTML+ tags, like +h1+ for the highest-ranking header. All information provided after a custom class name, like +comments+, or a standard tag, like +h1+, defines or changes certain style elements (e.g., font type and/or size) of the relevant object.

This style information is the final ingredient defining the look of the Tradechat application and explaining why, for example, the "Tradechat" heading is displayed in blue (namely, due to the line +a, h1, h2 { color: #0066cc; }+).

[[style_css]]
.CSS stylesheet for Tradechat application
====
[source, css]
----
include::python/tradechat/static/style.css[]
----
====

If you have followed every step, your +tradechat+ directory should now contain the same files listed here:

// code cell start uuid: 41649870-1061-444f-924c-733ecdef2ebb
[source, python]
----
In [86]: import os
         for path, dirs, files in os.walk('../python/tradechat'):
           print path
           for f in files:
             print f
----

----
Out[86]: ../python/tradechat
         tables.sql
         tradechat.db
         tradechat.py
         ../python/tradechat/static
         style.css
         ../python/tradechat/templates
         layout.html
         login.html
         register.html
         show_entries.html
         
----

// code cell end

++++
<?hard-pagebreak?>
++++

You can now run the main script from the shell as follows and start the application:

----
$ python tradechat.py
----

(((range="endofrange", startref="ix_WTrapid")))(((range="endofrange", startref="ix_ADrapid")))(((range="endofrange", startref="ix_Pythrapid")))You can then access the application via your web browser at __http://127.0.0.1:5000__. Click on +register+ to register as a user, and after having provided a username and a password you will be able to post your comments.


=== Web Services

((("web technologies", "web services", id="ix_WTserv", range="startofrange")))((("communication protocols", "providing web services via", id="ix_CPserv", range="startofrange")))The last topic in this chapter--and a very interesting and important one--is web services. Web services provide a simple and efficient means to access server-based functionality via web protocols. For example, one of the web services with the highest traffic is the Google search functionality. We are used to visiting __http://www.google.com__ and typing some words of interest into the search/text input field provided on the website. However, what happens after you press the Return key or push the Search button is that the page translates all the information it has (from the search field and maybe your personal preferences) into a more or less complex +URL+.

Such a +URL+ could, for example, take on the form __http://www.google.de/search?num=5&q=yves+python__. When you click this link or copy it into your web browser, Google Search returns those five search results (+num=5+) that the engine considers the best matches given the words provided (+q=Yves+Python+). Your web browser then displays something similar to <<google_search>>.

Using web services, any kind of data- and transaction-oriented financial service can be provided via web technologies. For instance, Yahoo! Finance and Google Finance offer historical stock price information via such a web service approach. More complex services such as derivatives pricing and risk analytics are also available via such services (for example, the web-based analytics solution DEXISION; cf. http://derivatives-analytics.com[]). The following example illustrates the implementation of such a service in the context of option pricing.

[[google_search]]
.Screenshot of Google search results via web service
image::images/pyfi_1411.png[]


==== The Financial Model

(((volatility index)))(((Gruenbichler and Longstaff model)))In this section, we are going to implement a web service that allows us to value volatility options (e.g., on a volatility index). The model we use is the one of Gruenbichler and Longstaff (1996). They model the volatility process (e.g., the process of a volatility index) in direct fashion by a square-root diffusion, provided in <<srd_gl96>>. This process is known to exhibit convenient features for volatility modeling, like positivity and mean reversion.footnote:[See also the larger case study about volatility options presented in <<volatility_options>>.]

[[srd_gl96]]
[latexmath]
.Square-root diffusion for volatility modeling
++++
\begin{equation*}
dV_t = \kappa_V (\theta_V - V_t)dt + \sigma_V \sqrt{V_t} dZ
\end{equation*}
++++

The variables and parameters in <<srd_gl96>> have the following meanings:

__V~t~__::
    The time __t__ value of the volatility index (for example, the VSTOXX)
&#x3b8;~__V__~::
    The long-run mean of the volatility index
&#x3ba;~__V__~::
    The rate at which __V~t~__ reverts to &#x1d703;
&#x3a3;~__V__~::
    The volatility of the volatility ("vol-vol")
&#x3b8;~__V__~, &#x3ba;~__V__~, and &#x3a3;~__V__~::
    Assumed to be constant and positive
__Z~t~__::
    A standard Brownian motion

Based on this model, Gruenbichler and Longstaff (1996) derive the formula provided in <<formula_gl96>> for the value of a European call option. In the formula, __D__(__T__) is the appropriate discount factor. The parameter &#x1d701; denotes the expected premium for volatility risk, while latexmath:[$Q(\cdot)$] is the complementary noncentral &#x1d712;^2^ distribution.

[[formula_gl96]]
[latexmath]
.Call option formula of Gruenbichler and Longstaff (1996)
++++
\begin{eqnarray*}
C(V_0,K,T) &=& D(T)\cdot e^{- \beta T} \cdot V_0 \cdot Q(\gamma \cdot K | \nu + 4, \lambda)\\
&+& D(T)\cdot \left(\frac{\alpha}{\beta}\right) \cdot \left(1-e^{- \beta T}\right) \cdot Q(\gamma \cdot K | \nu+2,  \lambda) \\
&-& D(T) \cdot K \cdot Q(\gamma \cdot K | \nu, \lambda) \\
\alpha &=& \kappa  \theta \\
\beta &=& \kappa + \zeta \\
\gamma &=& \frac{4 \beta}{\sigma^2 \left(1-e^{- \beta T}\right)} \\
\nu &=& \frac{4 \alpha}{\sigma^2} \\
\lambda &=& \gamma \cdot e^{- \beta T} \cdot V
\end{eqnarray*}
++++


==== The Implementation

The translation of the formula as presented in <<formula_gl96>> to +Python+ is, as usual, quite straightforward. <<vol_pricing_formula_py>> shows the code of a +Python+ module with such a valuation function. We call the script +vol_pricing_formula.py+ and store it in a sub-directory, +volservice+.

[[vol_pricing_formula_py]]
.Python script for volatility option valuation
====
[source, python]
----
include::python/volservice/vol_pricing_formula.py[]
----
====

To simplify the implementation of the web service we write a convenience function, +get_option_value+, which will check for the provision of all needed parameters to calculate a call option value. The function is stored in a +Python+ module called +vol_pricing_service.py+, the code of which is shown in <<vol_pricing_service_py>>. This script also contains a dictionary with all the necessary parameters and brief descriptions of these parameters. The function will return an error message detailing what is missing whenever one or more parameters are missing. If all necessary parameters are provided during the web service call, the function calls the pricing function +calculate_option_value+ from the +vol_pricing_formula.py+ script.

[[vol_pricing_service_py]]
.Python script for volatility option valuation and web service helper pass:[<phrase role="keep-together">function</phrase>]
====
[source, python]
----
include::python/volservice/vol_pricing_service.py[]
----
====

To begin with, we add the path of the aforementioned +Python+ scripts:

// code cell start uuid: 79f9048b-3427-4a79-9cbc-4bf414c0730c
[source, python]
----
In [87]: import sys
         sys.path.append("../python/volservice")
           # adjust if necessary to your path
----

// code cell end

We use the library +Werkzeug+ to handle our +WSGI+ application-based web service (recall that +Werkzeug+ is an integral part of +Flask+). To this end, we need to import some functions from +Werkzeug+ sublibraries:

// code cell start uuid: baba8c94-1d56-42aa-a491-da6b7a9f649f
[source, python]
----
In [88]: from werkzeug.wrappers import Request, Response 
----

// code cell end

Furthermore, for our core +WSGI+ application to follow, we need the function +get_option_value+ that we defined earlier:

// code cell start uuid: 5cbccdda-a5a3-4c7e-97ac-3df9b05c5efb
[source, python]
----
In [89]: from vol_pricing_service import get_option_value
----

// code cell end

The only thing that remains is to implement the +WSGI+ application (function) itself. This function might in our case look as follows:

// code cell start uuid: b6bad926-3093-4f80-aedd-aef6e7950749
[source, python]
----
In [90]: def application(environ, start_response):
             request = Request(environ)
               # wrap environ in new object
             text = get_option_value(request.args)
               # provide all parameters of call to function
               # get back either error message or option value
             response = Response(text, mimetype='text/html')
               # generate response object based on the returned text
             return response(environ, start_response)
----

// code cell end

Here, +environ+ is a dictionary containing all incoming information. The +Request+ function wraps all information in a manner that makes accessing the +environ+ information a bit more convenient. +start_response+ is usually used to indicate the start of a response. However, with +Werkzeug+ you have the +Response+ function, which takes care of the pass:[<phrase role="keep-together">response</phrase>].

All parameters provided to the web service are found in the +request.args+ attribute, and this is what we provide to the +get_option_value+ function. This function returns either an error message in text form or the calculated option value in text form.

To be better able to serve this function (e.g., via a local web server), we put the function into a separate +WSGI+ script and add the serving functionality to it. <<vol_pricing_wsgi>> shows the code of this script, called +vol_pricing.py+.

[[vol_pricing_wsgi]]
.Python script for volatility option valuation and web service helper function
====
[source, python]
----
include::python/volservice/vol_pricing.py[]
----
====

Being in the right subdirectory (++volservice++), you can now start the application by executing the following command via the shell or command-line interface:

----
$ python vol_pricing.py
 * Running on http://localhost:4000/
----

This fires up a separate +Python+ process that serves the +WSGI+ application. Using +urllib+, we can now access the "full power" of the web service. Copying the +URL+ in your web browser and pressing the Return key yields something like the result shown in <<web_service>>.

[[web_service]]
.Screenshot of the error message of the web service
image::images/pyfi_1412.png[]

However, usually you want to use a web service quite a bit differently—for example, from a scripting environment like +IPython+. To this end, we can use the functionality the +urllib+ library provides:

// code cell start uuid: a5708e66-1b39-4f82-b07f-44cb07c68280
[source, python]
----
In [91]: import numpy as np
         import urllib
         url = 'http://localhost:4000/'
----

// code cell end

A simple call to the web service without providing any parameters returns the following error message, which (apart from formatting issues) is the same as in the screenshot in <<web_service>>:

// code cell start uuid: ecbeeb53-a2e0-4cd5-b81b-8ba292ff6aff
[source, python]
----
In [92]: print urllib.urlopen(url).read()
----

----
Out[92]: Missing parameter V0 (current volatility level)
         Missing parameter r (risk-free interest rate)
         Missing parameter kappa (mean-reversion factor)
         Missing parameter T (time horizon in years)
         Missing parameter theta (long-run mean of volatility)
         Missing parameter zeta (factor of the expected volatility risk premium)
         Missing parameter sigma (volatility of volatility)
         Missing parameter K (strike)
         
         
----

// code cell end

Of course, we need to provide a number of parameters. Therefore, we first build a +URL+ string object in which we can replace specific parameter values during later calls:

// code cell start uuid: 4f6b17a8-8404-4259-8918-b27e5e56c909
[source, python]
----
In [93]: urlpara = url + 'application?V0=%s&kappa=%s&theta=%s&sigma=%s&zeta=%s'
         urlpara += '&T=%s&r=%s&K=%s'
----

// code cell end

A possible parameterization might be the following one:

// code cell start uuid: 7955749b-4535-43a9-9b1f-c63cf6830682
[source, python]
----
In [94]: urlval = urlpara % (25, 2.0, 20, 1.0, 0.0, 1.5, 0.02, 22.5)
         urlval
----

----
Out[94]: 'http://localhost:4000/application?V0=25&kappa=2.0&theta=20&sigma=1.0&z
         eta=0.0&T=1.5&r=0.02&K=22.5'
----

// code cell end

Using this particular +URL+ string returns an option value, as desired:

// code cell start uuid: 7941ee86-775a-4b22-b355-5eac0e002cab
[source, python]
----
In [95]: print urllib.urlopen(urlval).read()
----

----
Out[95]: 0.202937705934
         
----

// code cell end

With such a web service, you can of course do multiple calls to calculate multiple option values quite easily:

// code cell start uuid: a59f62b9-ccc2-49cb-863b-877fd333987b
[source, python]
----
In [96]: %%time
         urlpara = 'http://localhost:4000/application?V0=25&kappa=2.0'
         urlpara += '&theta=25&sigma=1.0&zeta=0.0&T=1&r=0.02&K=%s'
         strikes = np.linspace(20, 30, 50)
         results = []
         for K in strikes:
             results.append(float(urllib.urlopen(urlpara % K).read()))
         results = np.array(results)
----

----
Out[96]: CPU times: user 64 ms, sys: 20 ms, total: 84 ms
         Wall time: 196 ms
         
----

// code cell end

// code cell start uuid: 631596a1-57d5-42b3-b6e5-c8f269f2aea9
[source, python]
----
In [97]: results
----

----
Out[97]: array([ 4.91296701,  4.71661296,  4.52120153,  4.32692516,  4.1339945 ,
                 3.94264561,  3.75313813,  3.56575972,  3.38079846,  3.19858765,
                 3.01946028,  2.8437621 ,  2.67184576,  2.50406508,  2.34078693,
                 2.18230495,  2.02898213,  1.88111287,  1.738968  ,  1.60280064,
                 1.47281111,  1.34917004,  1.23204859,  1.12141092,  1.01739405,
                 0.9199686 ,  0.82907686,  0.74462353,  0.66647327,  0.59445387,
                 0.52843174,  0.46798166,  0.41300694,  0.36319553,  0.31824647,
                 0.27785656,  0.24171678,  0.20951651,  0.18094732,  0.1557064 ,
                 0.1334996 ,  0.11414975,  0.09710449,  0.08234678,  0.06958767,
                 0.05859317,  0.04915788,  0.04109348,  0.03422854,  0.02840802])
----

// code cell end

One advantage of this approach is that you do not use your local resources to get the results, but rather the resources of a web server—which might also use, for example, parallelization techniques. Of course, in our example all is local and the web service uses the local computing resources. <<vol_values>> shows the valuation results graphically, concluding this section:

// code cell start uuid: ca8b41dd-0872-4cb6-b9d9-afb8f7686e61
[source, python]
----
In [98]: import matplotlib.pyplot as plt
         %matplotlib inline
         plt.plot(strikes, results, 'b')
         plt.plot(strikes, results, 'ro')
         plt.grid(True)
         plt.xlabel('strike')
         plt.ylabel('European call option value')
----

[[vol_values]]
.Value of European volatility call option for different strikes
image::images/pyfi_1413.png[]

// code cell end

.Web Services Architecture
[TIP]
====
(((range="endofrange", startref="ix_WTserv")))(((range="endofrange", startref="ix_CPserv")))The web services architecture is often a powerful and efficient alternative to the provision of +Python+-based analytical functionality, or even whole applications. This holds true for the Internet as well as for models where private networks are used. This architecture also simplifies updates and maintenance, since such services are generally provided in a centralized fashion.
====


=== Conclusions

Nowadays, web technologies are an integral part of almost any application architecture. They are not only beneficial for communicating with the outside world and providing simple to sophisticated web services to external entities, but also within (financial) pass:[<phrase role="keep-together">organizations</phrase>].

This chapter first illustrates some basic techniques with regard to the most common _communication protocols_ (mainly +FTP+ and +HTTP+). It also shows how to implement interactive _web plotting_, how to interface in real time with web-based financial data APIs (e.g., +JSON+-based) and how to visualize such high frequency data in real time with +Bokeh+. These basic tools and techniques are helpful in almost any context.

However, the +Python+ ecosystem also provides a number of powerful, _high level frameworks_ to develop even complex web applications in rapid fashion. We use +Flask+, a framework which has gained some popularity recently, to implement a simple chat room for traders with simple user administration (registration and login). All elements of a typical web application--core functionality in +Python+, templating with +Jinja2+, and styling with ++CSS++—are illustrated.

Finally, the last section in this chapter addresses the important topic of _web services_. Using the +Werkzeug+ library for a somewhat simplified handling of +WSGI+ applications, we implement a web-based pricing service for volatility options based on the model and formula of Gruenbichler and Longstaff (1996).


=== Further Reading

The following web resources are helpful with regard to the topics covered in this chapter:

* The +Python+ documentation should be a starting point for the basic tools and techniques shown in this chapter: http://docs.python.org; see also this overview page: http://docs.python.org/2/howto/webservers.html.
* You should consult the home page of +Bokeh+ for more on this webfocused plotting library: http://bokeh.pydata.org.
* For more on ++Flask++, start with the home page of the framework: http://flask.pocoo.org; also, download the +PDF+ documentation: https://media.readthedocs.org/pdf/flask/latest/flask.pdf.
* Apart from the +Python+ documentation itself, consult the home page of 
    the +Werkzeug+ library for more on web services: http://werkzeug.pocoo.org.

For a ++Flask++ reference in book form, see the following:

* Grinberg, Miguel (2014): pass:[<ulink url="http://shop.oreilly.com/product/0636920031116.do" role="orm:hideurl"><emphasis>Flask Web Development—Developing Web Applications with Python</emphasis></ulink>]. O'Reilly, Sebastopol, CA.

Finally, here is the research paper about the valuation of volatility options:

* Gruenbichler, Andreas and Francis Longstaff (1996): "Valuing Futures and Options on Volatility." _Journal of Banking and Finance_, Vol. 20, pp. 985–1001.

